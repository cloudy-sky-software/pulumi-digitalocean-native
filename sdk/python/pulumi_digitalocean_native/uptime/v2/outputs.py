# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'Alert',
    'Check',
    'MetaMeta',
    'Notification',
    'NotificationSlackItemProperties',
    'PageLinks',
    'PageLinksPagesProperties',
    'PreviousOutage',
    'RegionState',
    'RegionalState',
    'State',
]

@pulumi.output_type
class Alert(dict):
    def __init__(__self__, *,
                 comparison: Optional['AlertUpdatableComparison'] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 notifications: Optional['outputs.Notification'] = None,
                 period: Optional['AlertUpdatablePeriod'] = None,
                 threshold: Optional[_builtins.int] = None,
                 type: Optional['AlertUpdatableType'] = None):
        """
        :param 'AlertUpdatableComparison' comparison: The comparison operator used against the alert's threshold.
        :param _builtins.str id: A unique ID that can be used to identify and reference the alert.
        :param _builtins.str name: A human-friendly display name.
        :param 'Notification' notifications: The notification settings for a trigger alert.
        :param 'AlertUpdatablePeriod' period: Period of time the threshold must be exceeded to trigger the alert.
        :param _builtins.int threshold: The threshold at which the alert will enter a trigger state. The specific threshold is dependent on the alert type.
        :param 'AlertUpdatableType' type: The type of alert.
        """
        if comparison is not None:
            pulumi.set(__self__, "comparison", comparison)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> Optional['AlertUpdatableComparison']:
        """
        The comparison operator used against the alert's threshold.
        """
        return pulumi.get(self, "comparison")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference the alert.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A human-friendly display name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notifications(self) -> Optional['outputs.Notification']:
        """
        The notification settings for a trigger alert.
        """
        return pulumi.get(self, "notifications")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional['AlertUpdatablePeriod']:
        """
        Period of time the threshold must be exceeded to trigger the alert.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        """
        The threshold at which the alert will enter a trigger state. The specific threshold is dependent on the alert type.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['AlertUpdatableType']:
        """
        The type of alert.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class Check(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 regions: Optional[Sequence['CheckUpdatableRegionsItem']] = None,
                 target: Optional[_builtins.str] = None,
                 type: Optional['CheckUpdatableType'] = None):
        """
        :param _builtins.bool enabled: A boolean value indicating whether the check is enabled/disabled.
        :param _builtins.str id: A unique ID that can be used to identify and reference the check.
        :param _builtins.str name: A human-friendly display name.
        :param Sequence['CheckUpdatableRegionsItem'] regions: An array containing the selected regions to perform healthchecks from.
        :param _builtins.str target: The endpoint to perform healthchecks on.
        :param 'CheckUpdatableType' type: The type of health check to perform.
        """
        if enabled is None:
            enabled = True
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating whether the check is enabled/disabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference the check.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A human-friendly display name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence['CheckUpdatableRegionsItem']]:
        """
        An array containing the selected regions to perform healthchecks from.
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The endpoint to perform healthchecks on.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['CheckUpdatableType']:
        """
        The type of health check to perform.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetaMeta(dict):
    def __init__(__self__, *,
                 total: Optional[_builtins.int] = None):
        """
        :param _builtins.int total: Number of objects returned by the request.
        """
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[_builtins.int]:
        """
        Number of objects returned by the request.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class Notification(dict):
    """
    The notification settings for a trigger alert.
    """
    def __init__(__self__, *,
                 email: Sequence[_builtins.str],
                 slack: Sequence['outputs.NotificationSlackItemProperties']):
        """
        The notification settings for a trigger alert.
        :param Sequence[_builtins.str] email: An email to notify on an alert trigger.
        :param Sequence['NotificationSlackItemProperties'] slack: Slack integration details.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "slack", slack)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Sequence[_builtins.str]:
        """
        An email to notify on an alert trigger.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def slack(self) -> Sequence['outputs.NotificationSlackItemProperties']:
        """
        Slack integration details.
        """
        return pulumi.get(self, "slack")


@pulumi.output_type
class NotificationSlackItemProperties(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: Slack channel to notify of an alert trigger.
        :param _builtins.str url: Slack Webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Slack channel to notify of an alert trigger.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Slack Webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PageLinks(dict):
    def __init__(__self__, *,
                 pages: Optional['outputs.PageLinksPagesProperties'] = None):
        if pages is not None:
            pulumi.set(__self__, "pages", pages)

    @_builtins.property
    @pulumi.getter
    def pages(self) -> Optional['outputs.PageLinksPagesProperties']:
        return pulumi.get(self, "pages")


@pulumi.output_type
class PageLinksPagesProperties(dict):
    def __init__(__self__, *,
                 first: Optional[_builtins.str] = None,
                 last: Optional[_builtins.str] = None,
                 next: Optional[_builtins.str] = None,
                 prev: Optional[_builtins.str] = None):
        if first is not None:
            pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if next is not None:
            pulumi.set(__self__, "next", next)
        if prev is not None:
            pulumi.set(__self__, "prev", prev)

    @_builtins.property
    @pulumi.getter
    def first(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "first")

    @_builtins.property
    @pulumi.getter
    def last(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last")

    @_builtins.property
    @pulumi.getter
    def next(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "next")

    @_builtins.property
    @pulumi.getter
    def prev(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prev")


@pulumi.output_type
class PreviousOutage(dict):
    def __init__(__self__, *,
                 duration_seconds: Optional[_builtins.int] = None,
                 ended_at: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None):
        if duration_seconds is not None:
            pulumi.set(__self__, "duration_seconds", duration_seconds)
        if ended_at is not None:
            pulumi.set(__self__, "ended_at", ended_at)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @_builtins.property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "duration_seconds")

    @_builtins.property
    @pulumi.getter(name="endedAt")
    def ended_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ended_at")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "started_at")


@pulumi.output_type
class RegionState(dict):
    def __init__(__self__, *,
                 status: Optional['RegionStateStatus'] = None,
                 status_changed_at: Optional[_builtins.str] = None,
                 thirty_day_uptime_percentage: Optional[_builtins.float] = None):
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_changed_at is not None:
            pulumi.set(__self__, "status_changed_at", status_changed_at)
        if thirty_day_uptime_percentage is not None:
            pulumi.set(__self__, "thirty_day_uptime_percentage", thirty_day_uptime_percentage)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['RegionStateStatus']:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusChangedAt")
    def status_changed_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status_changed_at")

    @_builtins.property
    @pulumi.getter(name="thirtyDayUptimePercentage")
    def thirty_day_uptime_percentage(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "thirty_day_uptime_percentage")


@pulumi.output_type
class RegionalState(dict):
    """
    A map of region to regional state
    """
    def __init__(__self__, *,
                 eu_west: Optional['outputs.RegionState'] = None,
                 us_east: Optional['outputs.RegionState'] = None):
        """
        A map of region to regional state
        """
        if eu_west is not None:
            pulumi.set(__self__, "eu_west", eu_west)
        if us_east is not None:
            pulumi.set(__self__, "us_east", us_east)

    @_builtins.property
    @pulumi.getter(name="euWest")
    def eu_west(self) -> Optional['outputs.RegionState']:
        return pulumi.get(self, "eu_west")

    @_builtins.property
    @pulumi.getter(name="usEast")
    def us_east(self) -> Optional['outputs.RegionState']:
        return pulumi.get(self, "us_east")


@pulumi.output_type
class State(dict):
    def __init__(__self__, *,
                 previous_outage: Optional['outputs.PreviousOutage'] = None,
                 regions: Optional['outputs.RegionalState'] = None):
        """
        :param 'RegionalState' regions: A map of region to regional state
        """
        if previous_outage is not None:
            pulumi.set(__self__, "previous_outage", previous_outage)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter(name="previousOutage")
    def previous_outage(self) -> Optional['outputs.PreviousOutage']:
        return pulumi.get(self, "previous_outage")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional['outputs.RegionalState']:
        """
        A map of region to regional state
        """
        return pulumi.get(self, "regions")


