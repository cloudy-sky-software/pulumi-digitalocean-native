# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DockerCredentials',
    'DockerCredentialsAuthsProperties',
    'DockerCredentialsAuthsPropertiesRegistryDigitaloceanComProperties',
    'GarbageCollection',
    'GetRegistryOptionProperties',
    'GetRegistryOptionPropertiesOptionsProperties',
    'GetRegistryOptionPropertiesOptionsPropertiesSubscriptionTiersItem',
    'GetRegistryProperties',
    'GetRegistrySubscriptionProperties',
    'ListRegistryGarbageCollectionsProperties',
    'ListRegistryRepositoriesItems',
    'ListRegistryRepositoriesV2Items',
    'ListRegistryRepositoryManifestsItems',
    'ListRegistryRepositoryTagsItems',
    'MetaMeta',
    'PageLinks',
    'PageLinksPagesProperties',
    'Registry',
    'RegistrySubscription',
    'Repository',
    'RepositoryBlob',
    'RepositoryManifest',
    'RepositoryTag',
    'RepositoryV2',
    'Subscription',
    'SubscriptionTierBase',
]

@pulumi.output_type
class DockerCredentials(dict):
    def __init__(__self__, *,
                 auths: Optional['outputs.DockerCredentialsAuthsProperties'] = None):
        if auths is not None:
            pulumi.set(__self__, "auths", auths)

    @property
    @pulumi.getter
    def auths(self) -> Optional['outputs.DockerCredentialsAuthsProperties']:
        return pulumi.get(self, "auths")


@pulumi.output_type
class DockerCredentialsAuthsProperties(dict):
    def __init__(__self__, *,
                 registry_digitalocean_com: Optional['outputs.DockerCredentialsAuthsPropertiesRegistryDigitaloceanComProperties'] = None):
        if registry_digitalocean_com is not None:
            pulumi.set(__self__, "registry_digitalocean_com", registry_digitalocean_com)

    @property
    @pulumi.getter(name="registryDigitaloceanCom")
    def registry_digitalocean_com(self) -> Optional['outputs.DockerCredentialsAuthsPropertiesRegistryDigitaloceanComProperties']:
        return pulumi.get(self, "registry_digitalocean_com")


@pulumi.output_type
class DockerCredentialsAuthsPropertiesRegistryDigitaloceanComProperties(dict):
    def __init__(__self__, *,
                 auth: Optional[str] = None):
        """
        :param str auth: A base64 encoded string containing credentials for the container registry.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)

    @property
    @pulumi.getter
    def auth(self) -> Optional[str]:
        """
        A base64 encoded string containing credentials for the container registry.
        """
        return pulumi.get(self, "auth")


@pulumi.output_type
class GarbageCollection(dict):
    def __init__(__self__, *,
                 blobs_deleted: Optional[int] = None,
                 created_at: Optional[str] = None,
                 freed_bytes: Optional[int] = None,
                 registry_name: Optional[str] = None,
                 status: Optional['GarbageCollectionStatus'] = None,
                 updated_at: Optional[str] = None,
                 uuid: Optional[str] = None):
        """
        :param int blobs_deleted: The number of blobs deleted as a result of this garbage collection.
        :param str created_at: The time the garbage collection was created.
        :param int freed_bytes: The number of bytes freed as a result of this garbage collection.
        :param str registry_name: The name of the container registry.
        :param 'GarbageCollectionStatus' status: The current status of this garbage collection.
        :param str updated_at: The time the garbage collection was last updated.
        :param str uuid: A string specifying the UUID of the garbage collection.
        """
        if blobs_deleted is not None:
            pulumi.set(__self__, "blobs_deleted", blobs_deleted)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if freed_bytes is not None:
            pulumi.set(__self__, "freed_bytes", freed_bytes)
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="blobsDeleted")
    def blobs_deleted(self) -> Optional[int]:
        """
        The number of blobs deleted as a result of this garbage collection.
        """
        return pulumi.get(self, "blobs_deleted")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The time the garbage collection was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="freedBytes")
    def freed_bytes(self) -> Optional[int]:
        """
        The number of bytes freed as a result of this garbage collection.
        """
        return pulumi.get(self, "freed_bytes")

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        The name of the container registry.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter
    def status(self) -> Optional['GarbageCollectionStatus']:
        """
        The current status of this garbage collection.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The time the garbage collection was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        A string specifying the UUID of the garbage collection.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetRegistryOptionProperties(dict):
    def __init__(__self__, *,
                 options: Optional['outputs.GetRegistryOptionPropertiesOptionsProperties'] = None):
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetRegistryOptionPropertiesOptionsProperties']:
        return pulumi.get(self, "options")


@pulumi.output_type
class GetRegistryOptionPropertiesOptionsProperties(dict):
    def __init__(__self__, *,
                 available_regions: Optional[Sequence[str]] = None,
                 subscription_tiers: Optional[Sequence['outputs.GetRegistryOptionPropertiesOptionsPropertiesSubscriptionTiersItem']] = None):
        if available_regions is not None:
            pulumi.set(__self__, "available_regions", available_regions)
        if subscription_tiers is not None:
            pulumi.set(__self__, "subscription_tiers", subscription_tiers)

    @property
    @pulumi.getter(name="availableRegions")
    def available_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "available_regions")

    @property
    @pulumi.getter(name="subscriptionTiers")
    def subscription_tiers(self) -> Optional[Sequence['outputs.GetRegistryOptionPropertiesOptionsPropertiesSubscriptionTiersItem']]:
        return pulumi.get(self, "subscription_tiers")


@pulumi.output_type
class GetRegistryOptionPropertiesOptionsPropertiesSubscriptionTiersItem(dict):
    def __init__(__self__, *,
                 allow_storage_overage: Optional[bool] = None,
                 eligibility_reasons: Optional[Sequence['SubscriptionTierExtendedEligibilityReasonsItem']] = None,
                 eligible: Optional[bool] = None,
                 included_bandwidth_bytes: Optional[int] = None,
                 included_repositories: Optional[int] = None,
                 included_storage_bytes: Optional[int] = None,
                 monthly_price_in_cents: Optional[int] = None,
                 name: Optional[str] = None,
                 slug: Optional[str] = None,
                 storage_overage_price_in_cents: Optional[int] = None):
        """
        :param bool allow_storage_overage: A boolean indicating whether the subscription tier supports additional storage above what is included in the base plan at an additional cost per GiB used.
        :param Sequence['SubscriptionTierExtendedEligibilityReasonsItem'] eligibility_reasons: If your account is not eligible to use a certain subscription tier, this will include a list of reasons that prevent you from using the tier.
        :param bool eligible: A boolean indicating whether your account it eligible to use a certain subscription tier.
        :param int included_bandwidth_bytes: The amount of outbound data transfer included in the subscription tier in bytes.
        :param int included_repositories: The number of repositories included in the subscription tier. `0` indicates that the subscription tier includes unlimited repositories.
        :param int included_storage_bytes: The amount of storage included in the subscription tier in bytes.
        :param int monthly_price_in_cents: The monthly cost of the subscription tier in cents.
        :param str name: The name of the subscription tier.
        :param str slug: The slug identifier of the subscription tier.
        :param int storage_overage_price_in_cents: The price paid in cents per GiB for additional storage beyond what is included in the subscription plan.
        """
        if allow_storage_overage is not None:
            pulumi.set(__self__, "allow_storage_overage", allow_storage_overage)
        if eligibility_reasons is not None:
            pulumi.set(__self__, "eligibility_reasons", eligibility_reasons)
        if eligible is not None:
            pulumi.set(__self__, "eligible", eligible)
        if included_bandwidth_bytes is not None:
            pulumi.set(__self__, "included_bandwidth_bytes", included_bandwidth_bytes)
        if included_repositories is not None:
            pulumi.set(__self__, "included_repositories", included_repositories)
        if included_storage_bytes is not None:
            pulumi.set(__self__, "included_storage_bytes", included_storage_bytes)
        if monthly_price_in_cents is not None:
            pulumi.set(__self__, "monthly_price_in_cents", monthly_price_in_cents)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)
        if storage_overage_price_in_cents is not None:
            pulumi.set(__self__, "storage_overage_price_in_cents", storage_overage_price_in_cents)

    @property
    @pulumi.getter(name="allowStorageOverage")
    def allow_storage_overage(self) -> Optional[bool]:
        """
        A boolean indicating whether the subscription tier supports additional storage above what is included in the base plan at an additional cost per GiB used.
        """
        return pulumi.get(self, "allow_storage_overage")

    @property
    @pulumi.getter(name="eligibilityReasons")
    def eligibility_reasons(self) -> Optional[Sequence['SubscriptionTierExtendedEligibilityReasonsItem']]:
        """
        If your account is not eligible to use a certain subscription tier, this will include a list of reasons that prevent you from using the tier.
        """
        return pulumi.get(self, "eligibility_reasons")

    @property
    @pulumi.getter
    def eligible(self) -> Optional[bool]:
        """
        A boolean indicating whether your account it eligible to use a certain subscription tier.
        """
        return pulumi.get(self, "eligible")

    @property
    @pulumi.getter(name="includedBandwidthBytes")
    def included_bandwidth_bytes(self) -> Optional[int]:
        """
        The amount of outbound data transfer included in the subscription tier in bytes.
        """
        return pulumi.get(self, "included_bandwidth_bytes")

    @property
    @pulumi.getter(name="includedRepositories")
    def included_repositories(self) -> Optional[int]:
        """
        The number of repositories included in the subscription tier. `0` indicates that the subscription tier includes unlimited repositories.
        """
        return pulumi.get(self, "included_repositories")

    @property
    @pulumi.getter(name="includedStorageBytes")
    def included_storage_bytes(self) -> Optional[int]:
        """
        The amount of storage included in the subscription tier in bytes.
        """
        return pulumi.get(self, "included_storage_bytes")

    @property
    @pulumi.getter(name="monthlyPriceInCents")
    def monthly_price_in_cents(self) -> Optional[int]:
        """
        The monthly cost of the subscription tier in cents.
        """
        return pulumi.get(self, "monthly_price_in_cents")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the subscription tier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        """
        The slug identifier of the subscription tier.
        """
        return pulumi.get(self, "slug")

    @property
    @pulumi.getter(name="storageOveragePriceInCents")
    def storage_overage_price_in_cents(self) -> Optional[int]:
        """
        The price paid in cents per GiB for additional storage beyond what is included in the subscription plan.
        """
        return pulumi.get(self, "storage_overage_price_in_cents")


@pulumi.output_type
class GetRegistryProperties(dict):
    def __init__(__self__, *,
                 registry: Optional['outputs.Registry'] = None):
        if registry is not None:
            pulumi.set(__self__, "registry", registry)

    @property
    @pulumi.getter
    def registry(self) -> Optional['outputs.Registry']:
        return pulumi.get(self, "registry")


@pulumi.output_type
class GetRegistrySubscriptionProperties(dict):
    def __init__(__self__, *,
                 subscription: Optional['outputs.Subscription'] = None):
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.Subscription']:
        return pulumi.get(self, "subscription")


@pulumi.output_type
class ListRegistryGarbageCollectionsProperties(dict):
    def __init__(__self__, *,
                 garbage_collections: Optional[Sequence['outputs.GarbageCollection']] = None):
        if garbage_collections is not None:
            pulumi.set(__self__, "garbage_collections", garbage_collections)

    @property
    @pulumi.getter(name="garbageCollections")
    def garbage_collections(self) -> Optional[Sequence['outputs.GarbageCollection']]:
        return pulumi.get(self, "garbage_collections")


@pulumi.output_type
class ListRegistryRepositoriesItems(dict):
    def __init__(__self__, *,
                 meta: 'outputs.MetaMeta',
                 links: Optional['outputs.PageLinks'] = None,
                 repositories: Optional[Sequence['outputs.Repository']] = None):
        pulumi.set(__self__, "meta", meta)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.MetaMeta':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def links(self) -> Optional['outputs.PageLinks']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def repositories(self) -> Optional[Sequence['outputs.Repository']]:
        return pulumi.get(self, "repositories")


@pulumi.output_type
class ListRegistryRepositoriesV2Items(dict):
    def __init__(__self__, *,
                 meta: 'outputs.MetaMeta',
                 links: Optional['outputs.PageLinks'] = None,
                 repositories: Optional[Sequence['outputs.RepositoryV2']] = None):
        pulumi.set(__self__, "meta", meta)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.MetaMeta':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def links(self) -> Optional['outputs.PageLinks']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def repositories(self) -> Optional[Sequence['outputs.RepositoryV2']]:
        return pulumi.get(self, "repositories")


@pulumi.output_type
class ListRegistryRepositoryManifestsItems(dict):
    def __init__(__self__, *,
                 meta: 'outputs.MetaMeta',
                 links: Optional['outputs.PageLinks'] = None,
                 manifests: Optional[Sequence['outputs.RepositoryManifest']] = None):
        pulumi.set(__self__, "meta", meta)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if manifests is not None:
            pulumi.set(__self__, "manifests", manifests)

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.MetaMeta':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def links(self) -> Optional['outputs.PageLinks']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def manifests(self) -> Optional[Sequence['outputs.RepositoryManifest']]:
        return pulumi.get(self, "manifests")


@pulumi.output_type
class ListRegistryRepositoryTagsItems(dict):
    def __init__(__self__, *,
                 meta: 'outputs.MetaMeta',
                 links: Optional['outputs.PageLinks'] = None,
                 tags: Optional[Sequence['outputs.RepositoryTag']] = None):
        pulumi.set(__self__, "meta", meta)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.MetaMeta':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def links(self) -> Optional['outputs.PageLinks']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.RepositoryTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class MetaMeta(dict):
    def __init__(__self__, *,
                 total: Optional[int] = None):
        """
        :param int total: Number of objects returned by the request.
        """
        if total is not None:
            pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def total(self) -> Optional[int]:
        """
        Number of objects returned by the request.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class PageLinks(dict):
    def __init__(__self__, *,
                 pages: Optional['outputs.PageLinksPagesProperties'] = None):
        if pages is not None:
            pulumi.set(__self__, "pages", pages)

    @property
    @pulumi.getter
    def pages(self) -> Optional['outputs.PageLinksPagesProperties']:
        return pulumi.get(self, "pages")


@pulumi.output_type
class PageLinksPagesProperties(dict):
    def __init__(__self__, *,
                 first: Optional[str] = None,
                 last: Optional[str] = None,
                 next: Optional[str] = None,
                 prev: Optional[str] = None):
        if first is not None:
            pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if next is not None:
            pulumi.set(__self__, "next", next)
        if prev is not None:
            pulumi.set(__self__, "prev", prev)

    @property
    @pulumi.getter
    def first(self) -> Optional[str]:
        return pulumi.get(self, "first")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def next(self) -> Optional[str]:
        return pulumi.get(self, "next")

    @property
    @pulumi.getter
    def prev(self) -> Optional[str]:
        return pulumi.get(self, "prev")


@pulumi.output_type
class Registry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "storageUsageBytes":
            suggest = "storage_usage_bytes"
        elif key == "storageUsageBytesUpdatedAt":
            suggest = "storage_usage_bytes_updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Registry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Registry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Registry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 name: Optional[str] = None,
                 region: Optional[str] = None,
                 storage_usage_bytes: Optional[int] = None,
                 storage_usage_bytes_updated_at: Optional[str] = None,
                 subscription: Optional['outputs.RegistrySubscription'] = None):
        """
        :param str created_at: A time value given in ISO8601 combined date and time format that represents when the registry was created.
        :param str name: A globally unique name for the container registry. Must be lowercase and be composed only of numbers, letters and `-`, up to a limit of 63 characters.
        :param str region: Slug of the region where registry data is stored
        :param int storage_usage_bytes: The amount of storage used in the registry in bytes.
        :param str storage_usage_bytes_updated_at: The time at which the storage usage was updated. Storage usage is calculated asynchronously, and may not immediately reflect pushes to the registry.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_usage_bytes is not None:
            pulumi.set(__self__, "storage_usage_bytes", storage_usage_bytes)
        if storage_usage_bytes_updated_at is not None:
            pulumi.set(__self__, "storage_usage_bytes_updated_at", storage_usage_bytes_updated_at)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        A time value given in ISO8601 combined date and time format that represents when the registry was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A globally unique name for the container registry. Must be lowercase and be composed only of numbers, letters and `-`, up to a limit of 63 characters.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Slug of the region where registry data is stored
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="storageUsageBytes")
    def storage_usage_bytes(self) -> Optional[int]:
        """
        The amount of storage used in the registry in bytes.
        """
        return pulumi.get(self, "storage_usage_bytes")

    @property
    @pulumi.getter(name="storageUsageBytesUpdatedAt")
    def storage_usage_bytes_updated_at(self) -> Optional[str]:
        """
        The time at which the storage usage was updated. Storage usage is calculated asynchronously, and may not immediately reflect pushes to the registry.
        """
        return pulumi.get(self, "storage_usage_bytes_updated_at")

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.RegistrySubscription']:
        return pulumi.get(self, "subscription")


@pulumi.output_type
class RegistrySubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 tier: Optional['outputs.SubscriptionTierBase'] = None,
                 updated_at: Optional[str] = None):
        """
        :param str created_at: The time at which the subscription was created.
        :param str updated_at: The time at which the subscription was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The time at which the subscription was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def tier(self) -> Optional['outputs.SubscriptionTierBase']:
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The time at which the subscription was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class Repository(dict):
    def __init__(__self__, *,
                 latest_tag: Optional['outputs.RepositoryTag'] = None,
                 name: Optional[str] = None,
                 registry_name: Optional[str] = None,
                 tag_count: Optional[int] = None):
        """
        :param str name: The name of the repository.
        :param str registry_name: The name of the container registry.
        :param int tag_count: The number of tags in the repository.
        """
        if latest_tag is not None:
            pulumi.set(__self__, "latest_tag", latest_tag)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if tag_count is not None:
            pulumi.set(__self__, "tag_count", tag_count)

    @property
    @pulumi.getter(name="latestTag")
    def latest_tag(self) -> Optional['outputs.RepositoryTag']:
        return pulumi.get(self, "latest_tag")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        The name of the container registry.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="tagCount")
    def tag_count(self) -> Optional[int]:
        """
        The number of tags in the repository.
        """
        return pulumi.get(self, "tag_count")


@pulumi.output_type
class RepositoryBlob(dict):
    def __init__(__self__, *,
                 compressed_size_bytes: Optional[int] = None,
                 digest: Optional[str] = None):
        """
        :param int compressed_size_bytes: The compressed size of the blob in bytes.
        :param str digest: The digest of the blob
        """
        if compressed_size_bytes is not None:
            pulumi.set(__self__, "compressed_size_bytes", compressed_size_bytes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)

    @property
    @pulumi.getter(name="compressedSizeBytes")
    def compressed_size_bytes(self) -> Optional[int]:
        """
        The compressed size of the blob in bytes.
        """
        return pulumi.get(self, "compressed_size_bytes")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        The digest of the blob
        """
        return pulumi.get(self, "digest")


@pulumi.output_type
class RepositoryManifest(dict):
    def __init__(__self__, *,
                 blobs: Optional[Sequence['outputs.RepositoryBlob']] = None,
                 compressed_size_bytes: Optional[int] = None,
                 digest: Optional[str] = None,
                 registry_name: Optional[str] = None,
                 repository: Optional[str] = None,
                 size_bytes: Optional[int] = None,
                 tags: Optional[Sequence[str]] = None,
                 updated_at: Optional[str] = None):
        """
        :param Sequence['RepositoryBlob'] blobs: All blobs associated with this manifest
        :param int compressed_size_bytes: The compressed size of the manifest in bytes.
        :param str digest: The manifest digest
        :param str registry_name: The name of the container registry.
        :param str repository: The name of the repository.
        :param int size_bytes: The uncompressed size of the manifest in bytes (this size is calculated asynchronously so it may not be immediately available).
        :param Sequence[str] tags: All tags associated with this manifest
        :param str updated_at: The time the manifest was last updated.
        """
        if blobs is not None:
            pulumi.set(__self__, "blobs", blobs)
        if compressed_size_bytes is not None:
            pulumi.set(__self__, "compressed_size_bytes", compressed_size_bytes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def blobs(self) -> Optional[Sequence['outputs.RepositoryBlob']]:
        """
        All blobs associated with this manifest
        """
        return pulumi.get(self, "blobs")

    @property
    @pulumi.getter(name="compressedSizeBytes")
    def compressed_size_bytes(self) -> Optional[int]:
        """
        The compressed size of the manifest in bytes.
        """
        return pulumi.get(self, "compressed_size_bytes")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        The manifest digest
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        The name of the container registry.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[int]:
        """
        The uncompressed size of the manifest in bytes (this size is calculated asynchronously so it may not be immediately available).
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        All tags associated with this manifest
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The time the manifest was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class RepositoryTag(dict):
    def __init__(__self__, *,
                 compressed_size_bytes: Optional[int] = None,
                 manifest_digest: Optional[str] = None,
                 registry_name: Optional[str] = None,
                 repository: Optional[str] = None,
                 size_bytes: Optional[int] = None,
                 tag: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param int compressed_size_bytes: The compressed size of the tag in bytes.
        :param str manifest_digest: The digest of the manifest associated with the tag.
        :param str registry_name: The name of the container registry.
        :param str repository: The name of the repository.
        :param int size_bytes: The uncompressed size of the tag in bytes (this size is calculated asynchronously so it may not be immediately available).
        :param str tag: The name of the tag.
        :param str updated_at: The time the tag was last updated.
        """
        if compressed_size_bytes is not None:
            pulumi.set(__self__, "compressed_size_bytes", compressed_size_bytes)
        if manifest_digest is not None:
            pulumi.set(__self__, "manifest_digest", manifest_digest)
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="compressedSizeBytes")
    def compressed_size_bytes(self) -> Optional[int]:
        """
        The compressed size of the tag in bytes.
        """
        return pulumi.get(self, "compressed_size_bytes")

    @property
    @pulumi.getter(name="manifestDigest")
    def manifest_digest(self) -> Optional[str]:
        """
        The digest of the manifest associated with the tag.
        """
        return pulumi.get(self, "manifest_digest")

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        The name of the container registry.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[int]:
        """
        The uncompressed size of the tag in bytes (this size is calculated asynchronously so it may not be immediately available).
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The time the tag was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class RepositoryV2(dict):
    def __init__(__self__, *,
                 latest_manifest: Optional['outputs.RepositoryManifest'] = None,
                 manifest_count: Optional[int] = None,
                 name: Optional[str] = None,
                 registry_name: Optional[str] = None,
                 tag_count: Optional[int] = None):
        """
        :param int manifest_count: The number of manifests in the repository.
        :param str name: The name of the repository.
        :param str registry_name: The name of the container registry.
        :param int tag_count: The number of tags in the repository.
        """
        if latest_manifest is not None:
            pulumi.set(__self__, "latest_manifest", latest_manifest)
        if manifest_count is not None:
            pulumi.set(__self__, "manifest_count", manifest_count)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if tag_count is not None:
            pulumi.set(__self__, "tag_count", tag_count)

    @property
    @pulumi.getter(name="latestManifest")
    def latest_manifest(self) -> Optional['outputs.RepositoryManifest']:
        return pulumi.get(self, "latest_manifest")

    @property
    @pulumi.getter(name="manifestCount")
    def manifest_count(self) -> Optional[int]:
        """
        The number of manifests in the repository.
        """
        return pulumi.get(self, "manifest_count")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        The name of the container registry.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="tagCount")
    def tag_count(self) -> Optional[int]:
        """
        The number of tags in the repository.
        """
        return pulumi.get(self, "tag_count")


@pulumi.output_type
class Subscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Subscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Subscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Subscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 tier: Optional['outputs.SubscriptionTierBase'] = None,
                 updated_at: Optional[str] = None):
        """
        :param str created_at: The time at which the subscription was created.
        :param str updated_at: The time at which the subscription was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The time at which the subscription was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def tier(self) -> Optional['outputs.SubscriptionTierBase']:
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The time at which the subscription was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class SubscriptionTierBase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowStorageOverage":
            suggest = "allow_storage_overage"
        elif key == "includedBandwidthBytes":
            suggest = "included_bandwidth_bytes"
        elif key == "includedRepositories":
            suggest = "included_repositories"
        elif key == "includedStorageBytes":
            suggest = "included_storage_bytes"
        elif key == "monthlyPriceInCents":
            suggest = "monthly_price_in_cents"
        elif key == "storageOveragePriceInCents":
            suggest = "storage_overage_price_in_cents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionTierBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionTierBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionTierBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_storage_overage: Optional[bool] = None,
                 included_bandwidth_bytes: Optional[int] = None,
                 included_repositories: Optional[int] = None,
                 included_storage_bytes: Optional[int] = None,
                 monthly_price_in_cents: Optional[int] = None,
                 name: Optional[str] = None,
                 slug: Optional[str] = None,
                 storage_overage_price_in_cents: Optional[int] = None):
        """
        :param bool allow_storage_overage: A boolean indicating whether the subscription tier supports additional storage above what is included in the base plan at an additional cost per GiB used.
        :param int included_bandwidth_bytes: The amount of outbound data transfer included in the subscription tier in bytes.
        :param int included_repositories: The number of repositories included in the subscription tier. `0` indicates that the subscription tier includes unlimited repositories.
        :param int included_storage_bytes: The amount of storage included in the subscription tier in bytes.
        :param int monthly_price_in_cents: The monthly cost of the subscription tier in cents.
        :param str name: The name of the subscription tier.
        :param str slug: The slug identifier of the subscription tier.
        :param int storage_overage_price_in_cents: The price paid in cents per GiB for additional storage beyond what is included in the subscription plan.
        """
        if allow_storage_overage is not None:
            pulumi.set(__self__, "allow_storage_overage", allow_storage_overage)
        if included_bandwidth_bytes is not None:
            pulumi.set(__self__, "included_bandwidth_bytes", included_bandwidth_bytes)
        if included_repositories is not None:
            pulumi.set(__self__, "included_repositories", included_repositories)
        if included_storage_bytes is not None:
            pulumi.set(__self__, "included_storage_bytes", included_storage_bytes)
        if monthly_price_in_cents is not None:
            pulumi.set(__self__, "monthly_price_in_cents", monthly_price_in_cents)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)
        if storage_overage_price_in_cents is not None:
            pulumi.set(__self__, "storage_overage_price_in_cents", storage_overage_price_in_cents)

    @property
    @pulumi.getter(name="allowStorageOverage")
    def allow_storage_overage(self) -> Optional[bool]:
        """
        A boolean indicating whether the subscription tier supports additional storage above what is included in the base plan at an additional cost per GiB used.
        """
        return pulumi.get(self, "allow_storage_overage")

    @property
    @pulumi.getter(name="includedBandwidthBytes")
    def included_bandwidth_bytes(self) -> Optional[int]:
        """
        The amount of outbound data transfer included in the subscription tier in bytes.
        """
        return pulumi.get(self, "included_bandwidth_bytes")

    @property
    @pulumi.getter(name="includedRepositories")
    def included_repositories(self) -> Optional[int]:
        """
        The number of repositories included in the subscription tier. `0` indicates that the subscription tier includes unlimited repositories.
        """
        return pulumi.get(self, "included_repositories")

    @property
    @pulumi.getter(name="includedStorageBytes")
    def included_storage_bytes(self) -> Optional[int]:
        """
        The amount of storage included in the subscription tier in bytes.
        """
        return pulumi.get(self, "included_storage_bytes")

    @property
    @pulumi.getter(name="monthlyPriceInCents")
    def monthly_price_in_cents(self) -> Optional[int]:
        """
        The monthly cost of the subscription tier in cents.
        """
        return pulumi.get(self, "monthly_price_in_cents")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the subscription tier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        """
        The slug identifier of the subscription tier.
        """
        return pulumi.get(self, "slug")

    @property
    @pulumi.getter(name="storageOveragePriceInCents")
    def storage_overage_price_in_cents(self) -> Optional[int]:
        """
        The price paid in cents per GiB for additional storage beyond what is included in the subscription plan.
        """
        return pulumi.get(self, "storage_overage_price_in_cents")


