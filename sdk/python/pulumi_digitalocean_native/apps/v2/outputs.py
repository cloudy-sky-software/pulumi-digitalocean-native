# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'App',
    'AppAlert',
    'AppAlertProgress',
    'AppAlertProgressStep',
    'AppAlertProgressStepReason',
    'AppAlertSlackWebhook',
    'AppAlertSpec',
    'AppDatabaseSpec',
    'AppDomainSpec',
    'AppDomainValidation',
    'AppFunctionsSpec',
    'AppIngressSpec',
    'AppIngressSpecRule',
    'AppIngressSpecRuleMatch',
    'AppIngressSpecRuleRoutingComponent',
    'AppIngressSpecRuleRoutingRedirect',
    'AppIngressSpecRuleStringMatch',
    'AppJobSpec',
    'AppLogDestinationDatadogSpec',
    'AppLogDestinationDefinition',
    'AppLogDestinationLogtailSpec',
    'AppLogDestinationPapertrailSpec',
    'AppMetricsBandwidthUsageDetails',
    'AppPendingDeployment',
    'AppPinnedDeployment',
    'AppRollbackValidationCondition',
    'AppRouteSpec',
    'AppServiceSpec',
    'AppServiceSpecHealthCheck',
    'AppSpec',
    'AppStaticSiteSpec',
    'AppVariableDefinition',
    'AppWorkerSpec',
    'AppsCorsPolicy',
    'AppsDeployment',
    'AppsDeploymentFunctions',
    'AppsDeploymentJob',
    'AppsDeploymentProgress',
    'AppsDeploymentProgressStep',
    'AppsDeploymentProgressStepReason',
    'AppsDeploymentService',
    'AppsDeploymentStaticSite',
    'AppsDeploymentWorker',
    'AppsDomain',
    'AppsDomainProgress',
    'AppsGitSourceSpec',
    'AppsGithubSourceSpec',
    'AppsGitlabSourceSpec',
    'AppsImageSourceSpec',
    'AppsInstanceSize',
    'AppsRegion',
    'AppsStringMatch',
    'AppsTier',
    'Error',
    'MetaMeta',
    'PageLinks',
    'PageLinksPagesProperties',
]

@pulumi.output_type
class App(dict):
    """
    An application's configuration and status.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeployment":
            suggest = "active_deployment"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "defaultIngress":
            suggest = "default_ingress"
        elif key == "inProgressDeployment":
            suggest = "in_progress_deployment"
        elif key == "lastDeploymentCreatedAt":
            suggest = "last_deployment_created_at"
        elif key == "liveDomain":
            suggest = "live_domain"
        elif key == "liveUrl":
            suggest = "live_url"
        elif key == "liveUrlBase":
            suggest = "live_url_base"
        elif key == "ownerUuid":
            suggest = "owner_uuid"
        elif key == "pendingDeployment":
            suggest = "pending_deployment"
        elif key == "pinnedDeployment":
            suggest = "pinned_deployment"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "tierSlug":
            suggest = "tier_slug"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in App. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        App.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        App.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spec: 'outputs.AppSpec',
                 active_deployment: Optional['outputs.AppsDeployment'] = None,
                 created_at: Optional[_builtins.str] = None,
                 default_ingress: Optional[_builtins.str] = None,
                 domains: Optional[Sequence['outputs.AppsDomain']] = None,
                 id: Optional[_builtins.str] = None,
                 in_progress_deployment: Optional['outputs.AppsDeployment'] = None,
                 last_deployment_created_at: Optional[_builtins.str] = None,
                 live_domain: Optional[_builtins.str] = None,
                 live_url: Optional[_builtins.str] = None,
                 live_url_base: Optional[_builtins.str] = None,
                 owner_uuid: Optional[_builtins.str] = None,
                 pending_deployment: Optional['outputs.AppPendingDeployment'] = None,
                 pinned_deployment: Optional['outputs.AppPinnedDeployment'] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional['outputs.AppsRegion'] = None,
                 tier_slug: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        An application's configuration and status.
        :param 'AppSpec' spec: The desired configuration of an application.
        """
        pulumi.set(__self__, "spec", spec)
        if active_deployment is not None:
            pulumi.set(__self__, "active_deployment", active_deployment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if default_ingress is not None:
            pulumi.set(__self__, "default_ingress", default_ingress)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if in_progress_deployment is not None:
            pulumi.set(__self__, "in_progress_deployment", in_progress_deployment)
        if last_deployment_created_at is not None:
            pulumi.set(__self__, "last_deployment_created_at", last_deployment_created_at)
        if live_domain is not None:
            pulumi.set(__self__, "live_domain", live_domain)
        if live_url is not None:
            pulumi.set(__self__, "live_url", live_url)
        if live_url_base is not None:
            pulumi.set(__self__, "live_url_base", live_url_base)
        if owner_uuid is not None:
            pulumi.set(__self__, "owner_uuid", owner_uuid)
        if pending_deployment is not None:
            pulumi.set(__self__, "pending_deployment", pending_deployment)
        if pinned_deployment is not None:
            pulumi.set(__self__, "pinned_deployment", pinned_deployment)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tier_slug is not None:
            pulumi.set(__self__, "tier_slug", tier_slug)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> 'outputs.AppSpec':
        """
        The desired configuration of an application.
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="activeDeployment")
    def active_deployment(self) -> Optional['outputs.AppsDeployment']:
        return pulumi.get(self, "active_deployment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="defaultIngress")
    def default_ingress(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_ingress")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[Sequence['outputs.AppsDomain']]:
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inProgressDeployment")
    def in_progress_deployment(self) -> Optional['outputs.AppsDeployment']:
        return pulumi.get(self, "in_progress_deployment")

    @_builtins.property
    @pulumi.getter(name="lastDeploymentCreatedAt")
    def last_deployment_created_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last_deployment_created_at")

    @_builtins.property
    @pulumi.getter(name="liveDomain")
    def live_domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "live_domain")

    @_builtins.property
    @pulumi.getter(name="liveUrl")
    def live_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "live_url")

    @_builtins.property
    @pulumi.getter(name="liveUrlBase")
    def live_url_base(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "live_url_base")

    @_builtins.property
    @pulumi.getter(name="ownerUuid")
    def owner_uuid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "owner_uuid")

    @_builtins.property
    @pulumi.getter(name="pendingDeployment")
    def pending_deployment(self) -> Optional['outputs.AppPendingDeployment']:
        return pulumi.get(self, "pending_deployment")

    @_builtins.property
    @pulumi.getter(name="pinnedDeployment")
    def pinned_deployment(self) -> Optional['outputs.AppPinnedDeployment']:
        return pulumi.get(self, "pinned_deployment")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional['outputs.AppsRegion']:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tierSlug")
    def tier_slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_slug")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class AppAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentName":
            suggest = "component_name"
        elif key == "slackWebhooks":
            suggest = "slack_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_name: Optional[_builtins.str] = None,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 id: Optional[_builtins.str] = None,
                 phase: Optional['AppAlertPhase'] = None,
                 progress: Optional['outputs.AppAlertProgress'] = None,
                 slack_webhooks: Optional[Sequence['outputs.AppAlertSlackWebhook']] = None,
                 spec: Optional['outputs.AppAlertSpec'] = None):
        if component_name is not None:
            pulumi.set(__self__, "component_name", component_name)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if phase is None:
            phase = 'UNKNOWN'
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter(name="componentName")
    def component_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "component_name")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional['AppAlertPhase']:
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> Optional['outputs.AppAlertProgress']:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.AppAlertSlackWebhook']]:
        return pulumi.get(self, "slack_webhooks")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.AppAlertSpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class AppAlertProgress(dict):
    def __init__(__self__, *,
                 steps: Optional[Sequence['outputs.AppAlertProgressStep']] = None):
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.AppAlertProgressStep']]:
        return pulumi.get(self, "steps")


@pulumi.output_type
class AppAlertProgressStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedAt":
            suggest = "ended_at"
        elif key == "startedAt":
            suggest = "started_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppAlertProgressStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppAlertProgressStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppAlertProgressStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 reason: Optional['outputs.AppAlertProgressStepReason'] = None,
                 started_at: Optional[_builtins.str] = None,
                 status: Optional['AppAlertProgressStepStatus'] = None):
        if ended_at is not None:
            pulumi.set(__self__, "ended_at", ended_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if status is None:
            status = 'UNKNOWN'
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endedAt")
    def ended_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ended_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional['outputs.AppAlertProgressStepReason']:
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['AppAlertProgressStepStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class AppAlertProgressStepReason(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class AppAlertSlackWebhook(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class AppAlertSpec(dict):
    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 operator: Optional['AppAlertSpecOperator'] = None,
                 rule: Optional['AppAlertSpecRule'] = None,
                 value: Optional[_builtins.float] = None,
                 window: Optional['AppAlertSpecWindow'] = None):
        """
        :param _builtins.bool disabled: Is the alert disabled?
        :param _builtins.float value: Threshold value for alert
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if operator is None:
            operator = 'UNSPECIFIED_OPERATOR'
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if rule is None:
            rule = 'UNSPECIFIED_RULE'
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if window is None:
            window = 'UNSPECIFIED_WINDOW'
        if window is not None:
            pulumi.set(__self__, "window", window)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Is the alert disabled?
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional['AppAlertSpecOperator']:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional['AppAlertSpecRule']:
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.float]:
        """
        Threshold value for alert
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> Optional['AppAlertSpecWindow']:
        return pulumi.get(self, "window")


@pulumi.output_type
class AppDatabaseSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUser":
            suggest = "db_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDatabaseSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDatabaseSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDatabaseSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 cluster_name: Optional[_builtins.str] = None,
                 db_name: Optional[_builtins.str] = None,
                 db_user: Optional[_builtins.str] = None,
                 engine: Optional['AppDatabaseSpecEngine'] = None,
                 production: Optional[_builtins.bool] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name. Must be unique across all components within the same app.
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.
        :param _builtins.str db_name: The name of the MySQL or PostgreSQL database to configure.
        :param _builtins.str db_user: The name of the MySQL or PostgreSQL user to configure.
        :param 'AppDatabaseSpecEngine' engine: - MYSQL: MySQL
               - PG: PostgreSQL
               - REDIS: Redis
        :param _builtins.bool production: Whether this is a production or dev database.
        :param _builtins.str version: The version of the database engine
        """
        pulumi.set(__self__, "name", name)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if engine is None:
            engine = 'UNSET'
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if production is not None:
            pulumi.set(__self__, "production", production)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name. Must be unique across all components within the same app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[_builtins.str]:
        """
        The name of the MySQL or PostgreSQL user to configure.
        """
        return pulumi.get(self, "db_user")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional['AppDatabaseSpecEngine']:
        """
        - MYSQL: MySQL
        - PG: PostgreSQL
        - REDIS: Redis
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional[_builtins.bool]:
        """
        Whether this is a production or dev database.
        """
        return pulumi.get(self, "production")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the database engine
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AppDomainSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumTlsVersion":
            suggest = "minimum_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDomainSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDomainSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDomainSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: _builtins.str,
                 minimum_tls_version: Optional['AppDomainSpecMinimumTlsVersion'] = None,
                 type: Optional['AppDomainSpecType'] = None,
                 wildcard: Optional[_builtins.bool] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: The hostname for the domain
        :param 'AppDomainSpecMinimumTlsVersion' minimum_tls_version: The minimum version of TLS a client application can use to access resources for the domain.  Must be one of the following values wrapped within quotations: `"1.2"` or `"1.3"`.
        :param 'AppDomainSpecType' type: - DEFAULT: The default `.ondigitalocean.app` domain assigned to this app
               - PRIMARY: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
               - ALIAS: A non-primary domain
        :param _builtins.bool wildcard: Indicates whether the domain includes all sub-domains, in addition to the given domain
        :param _builtins.str zone: Optional. If the domain uses DigitalOcean DNS and you would like App
               Platform to automatically manage it for you, set this to the name of the
               domain on your account.
               
               For example, If the domain you are adding is `app.domain.com`, the zone
               could be `domain.com`.
        """
        pulumi.set(__self__, "domain", domain)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if type is None:
            type = 'UNSPECIFIED'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The hostname for the domain
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional['AppDomainSpecMinimumTlsVersion']:
        """
        The minimum version of TLS a client application can use to access resources for the domain.  Must be one of the following values wrapped within quotations: `"1.2"` or `"1.3"`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['AppDomainSpecType']:
        """
        - DEFAULT: The default `.ondigitalocean.app` domain assigned to this app
        - PRIMARY: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
        - ALIAS: A non-primary domain
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the domain includes all sub-domains, in addition to the given domain
        """
        return pulumi.get(self, "wildcard")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        Optional. If the domain uses DigitalOcean DNS and you would like App
        Platform to automatically manage it for you, set this to the name of the
        domain on your account.

        For example, If the domain you are adding is `app.domain.com`, the zone
        could be `domain.com`.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class AppDomainValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "txtName":
            suggest = "txt_name"
        elif key == "txtValue":
            suggest = "txt_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDomainValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDomainValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDomainValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 txt_name: Optional[_builtins.str] = None,
                 txt_value: Optional[_builtins.str] = None):
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @_builtins.property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "txt_name")

    @_builtins.property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "txt_value")


@pulumi.output_type
class AppFunctionsSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDestinations":
            suggest = "log_destinations"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppFunctionsSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppFunctionsSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppFunctionsSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.AppAlertSpec']] = None,
                 cors: Optional['outputs.AppsCorsPolicy'] = None,
                 envs: Optional[Sequence['outputs.AppVariableDefinition']] = None,
                 git: Optional['outputs.AppsGitSourceSpec'] = None,
                 github: Optional['outputs.AppsGithubSourceSpec'] = None,
                 gitlab: Optional['outputs.AppsGitlabSourceSpec'] = None,
                 log_destinations: Optional['outputs.AppLogDestinationDefinition'] = None,
                 routes: Optional[Sequence['outputs.AppRouteSpec']] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name. Must be unique across all components within the same app.
        :param Sequence['AppVariableDefinition'] envs: A list of environment variables made available to the component.
        :param Sequence['AppRouteSpec'] routes: A list of HTTP routes that should be routed to this component.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name. Must be unique across all components within the same app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.AppAlertSpec']]:
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppsCorsPolicy']:
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppVariableDefinition']]:
        """
        A list of environment variables made available to the component.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppsGitSourceSpec']:
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppsGithubSourceSpec']:
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppsGitlabSourceSpec']:
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional['outputs.AppLogDestinationDefinition']:
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.AppRouteSpec']]:
        """
        A list of HTTP routes that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppIngressSpec(dict):
    """
    Specification for app ingress configurations.
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AppIngressSpecRule']] = None):
        """
        Specification for app ingress configurations.
        :param Sequence['AppIngressSpecRule'] rules: Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AppIngressSpecRule']]:
        """
        Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AppIngressSpecRule(dict):
    def __init__(__self__, *,
                 component: Optional['outputs.AppIngressSpecRuleRoutingComponent'] = None,
                 cors: Optional['outputs.AppsCorsPolicy'] = None,
                 match: Optional['outputs.AppIngressSpecRuleMatch'] = None,
                 redirect: Optional['outputs.AppIngressSpecRuleRoutingRedirect'] = None):
        """
        :param 'AppIngressSpecRuleRoutingComponent' component: The component to route to. Only one of `component` or `redirect` may be set.
        :param 'AppIngressSpecRuleMatch' match: The match configuration for the rule.
        :param 'AppIngressSpecRuleRoutingRedirect' redirect: The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional['outputs.AppIngressSpecRuleRoutingComponent']:
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppsCorsPolicy']:
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional['outputs.AppIngressSpecRuleMatch']:
        """
        The match configuration for the rule.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.AppIngressSpecRuleRoutingRedirect']:
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "redirect")


@pulumi.output_type
class AppIngressSpecRuleMatch(dict):
    """
    The match configuration for the rule.
    """
    def __init__(__self__, *,
                 path: 'outputs.AppIngressSpecRuleStringMatch'):
        """
        The match configuration for the rule.
        :param 'AppIngressSpecRuleStringMatch' path: The path to match on.
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> 'outputs.AppIngressSpecRuleStringMatch':
        """
        The path to match on.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class AppIngressSpecRuleRoutingComponent(dict):
    """
    The component to route to. Only one of `component` or `redirect` may be set.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preservePathPrefix":
            suggest = "preserve_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppIngressSpecRuleRoutingComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppIngressSpecRuleRoutingComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppIngressSpecRuleRoutingComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 preserve_path_prefix: Optional[_builtins.str] = None,
                 rewrite: Optional[_builtins.str] = None):
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        :param _builtins.str name: The name of the component to route to.
        :param _builtins.str preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component. For example, a component with `path=/api` will have requests to `/api/list` trimmed to `/list`. If this value is `true`, the path will remain `/api/list`. Note: this is not applicable for Functions Components and is mutually exclusive with `rewrite`.
        :param _builtins.str rewrite: An optional field that will rewrite the path of the component to be what is specified here. By default, the HTTP request path will be trimmed from the left when forwarded to the component. For example, a component with `path=/api` will have requests to `/api/list` trimmed to `/list`. If you specified the rewrite to be `/v1/`, requests to `/api/list` would be rewritten to `/v1/list`. Note: this is mutually exclusive with `preserve_path_prefix`.
        """
        pulumi.set(__self__, "name", name)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component to route to.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.str]:
        """
        An optional flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component. For example, a component with `path=/api` will have requests to `/api/list` trimmed to `/list`. If this value is `true`, the path will remain `/api/list`. Note: this is not applicable for Functions Components and is mutually exclusive with `rewrite`.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @_builtins.property
    @pulumi.getter
    def rewrite(self) -> Optional[_builtins.str]:
        """
        An optional field that will rewrite the path of the component to be what is specified here. By default, the HTTP request path will be trimmed from the left when forwarded to the component. For example, a component with `path=/api` will have requests to `/api/list` trimmed to `/list`. If you specified the rewrite to be `/v1/`, requests to `/api/list` would be rewritten to `/v1/list`. Note: this is mutually exclusive with `preserve_path_prefix`.
        """
        return pulumi.get(self, "rewrite")


@pulumi.output_type
class AppIngressSpecRuleRoutingRedirect(dict):
    """
    The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectCode":
            suggest = "redirect_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppIngressSpecRuleRoutingRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppIngressSpecRuleRoutingRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppIngressSpecRuleRoutingRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 redirect_code: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        :param _builtins.str authority: The authority/host to redirect to. This can be a hostname or IP address. Note: use `port` to set the port.
        :param _builtins.int port: The port to redirect to.
        :param _builtins.int redirect_code: The redirect code to use. Defaults to `302`. Supported values are 300, 301, 302, 303, 304, 307, 308.
        :param _builtins.str scheme: The scheme to redirect to. Supported values are `http` or `https`. Default: `https`.
        :param _builtins.str uri: An optional URI path to redirect to. Note: if this is specified the whole URI of the original request will be overwritten to this value, irrespective of the original request URI being matched.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional[_builtins.str]:
        """
        The authority/host to redirect to. This can be a hostname or IP address. Note: use `port` to set the port.
        """
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to redirect to.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[_builtins.int]:
        """
        The redirect code to use. Defaults to `302`. Supported values are 300, 301, 302, 303, 304, 307, 308.
        """
        return pulumi.get(self, "redirect_code")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        The scheme to redirect to. Supported values are `http` or `https`. Default: `https`.
        """
        return pulumi.get(self, "scheme")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        An optional URI path to redirect to. Note: if this is specified the whole URI of the original request will be overwritten to this value, irrespective of the original request URI being matched.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class AppIngressSpecRuleStringMatch(dict):
    """
    The path to match on.
    """
    def __init__(__self__, *,
                 prefix: _builtins.str):
        """
        The path to match on.
        :param _builtins.str prefix: Prefix-based match. For example, `/api` will match `/api`, `/api/`, and any nested paths such as `/api/v1/endpoint`.
        """
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Prefix-based match. For example, `/api` will match `/api`, `/api/`, and any nested paths such as `/api/v1/endpoint`.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class AppJobSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceSizeSlug":
            suggest = "instance_size_slug"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppJobSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppJobSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppJobSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_command: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppVariableDefinition']] = None,
                 git: Optional['outputs.AppsGitSourceSpec'] = None,
                 github: Optional['outputs.AppsGithubSourceSpec'] = None,
                 gitlab: Optional['outputs.AppsGitlabSourceSpec'] = None,
                 image: Optional['outputs.AppsImageSourceSpec'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional['AppComponentInstanceBaseInstanceSizeSlug'] = None,
                 kind: Optional['AppJobSpecPropertiesKind'] = None,
                 log_destinations: Optional['outputs.AppLogDestinationDefinition'] = None,
                 name: Optional[_builtins.str] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        :param Sequence['AppVariableDefinition'] envs: A list of environment variables made available to the component.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to. Default: 1
        :param 'AppComponentInstanceBaseInstanceSizeSlug' instance_size_slug: The instance size to use for this component. Default: `basic-xxs`
        :param 'AppJobSpecPropertiesKind' kind: - UNSPECIFIED: Default job type, will auto-complete to POST_DEPLOY kind.
               - PRE_DEPLOY: Indicates a job that runs before an app deployment.
               - POST_DEPLOY: Indicates a job that runs after an app deployment.
               - FAILED_DEPLOY: Indicates a job that runs after a component fails to deploy.
        :param _builtins.str name: The name. Must be unique across all components within the same app.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is None:
            instance_size_slug = 'basic-xxs'
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if kind is None:
            kind = 'UNSPECIFIED'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppVariableDefinition']]:
        """
        A list of environment variables made available to the component.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppsGitSourceSpec']:
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppsGithubSourceSpec']:
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppsGitlabSourceSpec']:
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppsImageSourceSpec']:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to. Default: 1
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional['AppComponentInstanceBaseInstanceSizeSlug']:
        """
        The instance size to use for this component. Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional['AppJobSpecPropertiesKind']:
        """
        - UNSPECIFIED: Default job type, will auto-complete to POST_DEPLOY kind.
        - PRE_DEPLOY: Indicates a job that runs before an app deployment.
        - POST_DEPLOY: Indicates a job that runs after an app deployment.
        - FAILED_DEPLOY: Indicates a job that runs after a component fails to deploy.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional['outputs.AppLogDestinationDefinition']:
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name. Must be unique across all components within the same app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppLogDestinationDatadogSpec(dict):
    """
    DataDog configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLogDestinationDatadogSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLogDestinationDatadogSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLogDestinationDatadogSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        DataDog configuration.
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppLogDestinationDefinition(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.AppLogDestinationDatadogSpec'] = None,
                 logtail: Optional['outputs.AppLogDestinationLogtailSpec'] = None,
                 papertrail: Optional['outputs.AppLogDestinationPapertrailSpec'] = None):
        """
        :param 'AppLogDestinationDatadogSpec' datadog: DataDog configuration.
        :param 'AppLogDestinationLogtailSpec' logtail: Logtail configuration.
        :param 'AppLogDestinationPapertrailSpec' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.AppLogDestinationDatadogSpec']:
        """
        DataDog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.AppLogDestinationLogtailSpec']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.AppLogDestinationPapertrailSpec']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class AppLogDestinationLogtailSpec(dict):
    """
    Logtail configuration.
    """
    def __init__(__self__, *,
                 token: Optional[_builtins.str] = None):
        """
        Logtail configuration.
        :param _builtins.str token: Logtail token.
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class AppLogDestinationPapertrailSpec(dict):
    """
    Papertrail configuration.
    """
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        Papertrail configuration.
        :param _builtins.str endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppMetricsBandwidthUsageDetails(dict):
    """
    Bandwidth usage for an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "bandwidthBytes":
            suggest = "bandwidth_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppMetricsBandwidthUsageDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppMetricsBandwidthUsageDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppMetricsBandwidthUsageDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 bandwidth_bytes: Optional[_builtins.str] = None):
        """
        Bandwidth usage for an app.
        :param _builtins.str app_id: The ID of the app.
        :param _builtins.str bandwidth_bytes: The used bandwidth amount in bytes.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bandwidth_bytes is not None:
            pulumi.set(__self__, "bandwidth_bytes", bandwidth_bytes)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        The ID of the app.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bandwidthBytes")
    def bandwidth_bytes(self) -> Optional[_builtins.str]:
        """
        The used bandwidth amount in bytes.
        """
        return pulumi.get(self, "bandwidth_bytes")


@pulumi.output_type
class AppPendingDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clonedFrom":
            suggest = "cloned_from"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "phaseLastUpdatedAt":
            suggest = "phase_last_updated_at"
        elif key == "staticSites":
            suggest = "static_sites"
        elif key == "tierSlug":
            suggest = "tier_slug"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppPendingDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppPendingDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppPendingDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cause: Optional[_builtins.str] = None,
                 cloned_from: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 functions: Optional[Sequence['outputs.AppsDeploymentFunctions']] = None,
                 id: Optional[_builtins.str] = None,
                 jobs: Optional[Sequence['outputs.AppsDeploymentJob']] = None,
                 phase: Optional['AppsDeploymentPhase'] = None,
                 phase_last_updated_at: Optional[_builtins.str] = None,
                 progress: Optional['outputs.AppsDeploymentProgress'] = None,
                 services: Optional[Sequence['outputs.AppsDeploymentService']] = None,
                 spec: Optional['outputs.AppSpec'] = None,
                 static_sites: Optional[Sequence['outputs.AppsDeploymentStaticSite']] = None,
                 tier_slug: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 workers: Optional[Sequence['outputs.AppsDeploymentWorker']] = None):
        """
        :param 'AppSpec' spec: The desired configuration of an application.
        """
        if cause is not None:
            pulumi.set(__self__, "cause", cause)
        if cloned_from is not None:
            pulumi.set(__self__, "cloned_from", cloned_from)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if phase is None:
            phase = 'UNKNOWN'
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if phase_last_updated_at is not None:
            pulumi.set(__self__, "phase_last_updated_at", phase_last_updated_at)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if tier_slug is not None:
            pulumi.set(__self__, "tier_slug", tier_slug)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def cause(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cause")

    @_builtins.property
    @pulumi.getter(name="clonedFrom")
    def cloned_from(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloned_from")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AppsDeploymentFunctions']]:
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence['outputs.AppsDeploymentJob']]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional['AppsDeploymentPhase']:
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="phaseLastUpdatedAt")
    def phase_last_updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "phase_last_updated_at")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> Optional['outputs.AppsDeploymentProgress']:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.AppsDeploymentService']]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.AppSpec']:
        """
        The desired configuration of an application.
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[Sequence['outputs.AppsDeploymentStaticSite']]:
        return pulumi.get(self, "static_sites")

    @_builtins.property
    @pulumi.getter(name="tierSlug")
    def tier_slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_slug")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[Sequence['outputs.AppsDeploymentWorker']]:
        return pulumi.get(self, "workers")


@pulumi.output_type
class AppPinnedDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clonedFrom":
            suggest = "cloned_from"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "phaseLastUpdatedAt":
            suggest = "phase_last_updated_at"
        elif key == "staticSites":
            suggest = "static_sites"
        elif key == "tierSlug":
            suggest = "tier_slug"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppPinnedDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppPinnedDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppPinnedDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cause: Optional[_builtins.str] = None,
                 cloned_from: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 functions: Optional[Sequence['outputs.AppsDeploymentFunctions']] = None,
                 id: Optional[_builtins.str] = None,
                 jobs: Optional[Sequence['outputs.AppsDeploymentJob']] = None,
                 phase: Optional['AppsDeploymentPhase'] = None,
                 phase_last_updated_at: Optional[_builtins.str] = None,
                 progress: Optional['outputs.AppsDeploymentProgress'] = None,
                 services: Optional[Sequence['outputs.AppsDeploymentService']] = None,
                 spec: Optional['outputs.AppSpec'] = None,
                 static_sites: Optional[Sequence['outputs.AppsDeploymentStaticSite']] = None,
                 tier_slug: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 workers: Optional[Sequence['outputs.AppsDeploymentWorker']] = None):
        """
        :param 'AppSpec' spec: The desired configuration of an application.
        """
        if cause is not None:
            pulumi.set(__self__, "cause", cause)
        if cloned_from is not None:
            pulumi.set(__self__, "cloned_from", cloned_from)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if phase is None:
            phase = 'UNKNOWN'
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if phase_last_updated_at is not None:
            pulumi.set(__self__, "phase_last_updated_at", phase_last_updated_at)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if tier_slug is not None:
            pulumi.set(__self__, "tier_slug", tier_slug)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def cause(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cause")

    @_builtins.property
    @pulumi.getter(name="clonedFrom")
    def cloned_from(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloned_from")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AppsDeploymentFunctions']]:
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence['outputs.AppsDeploymentJob']]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional['AppsDeploymentPhase']:
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="phaseLastUpdatedAt")
    def phase_last_updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "phase_last_updated_at")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> Optional['outputs.AppsDeploymentProgress']:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.AppsDeploymentService']]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.AppSpec']:
        """
        The desired configuration of an application.
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[Sequence['outputs.AppsDeploymentStaticSite']]:
        return pulumi.get(self, "static_sites")

    @_builtins.property
    @pulumi.getter(name="tierSlug")
    def tier_slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_slug")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[Sequence['outputs.AppsDeploymentWorker']]:
        return pulumi.get(self, "workers")


@pulumi.output_type
class AppRollbackValidationCondition(dict):
    def __init__(__self__, *,
                 code: Optional['AppRollbackValidationConditionCode'] = None,
                 components: Optional[Sequence[_builtins.str]] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param 'AppRollbackValidationConditionCode' code: A code identifier that represents the failing condition.
               
               Failing conditions:
                 - `incompatible_phase` - indicates that the deployment's phase is not suitable for rollback.
                 - `incompatible_result` - indicates that the deployment's result is not suitable for rollback.
                 - `exceeded_revision_limit` - indicates that the app has exceeded the rollback revision limits for its tier.
                 - `app_pinned` - indicates that there is already a rollback in progress and the app is pinned.
                 - `database_config_conflict` - indicates that the deployment's database config is different than the current config.
                 - `region_conflict` - indicates that the deployment's region differs from the current app region.
                 
               Warning conditions:
                 - `static_site_requires_rebuild` - indicates that the deployment contains at least one static site that will require a rebuild.
                 - `image_source_missing_digest` - indicates that the deployment contains at least one component with an image source that is missing a digest.
        :param _builtins.str message: A human-readable message describing the failing condition.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional['AppRollbackValidationConditionCode']:
        """
        A code identifier that represents the failing condition.

        Failing conditions:
          - `incompatible_phase` - indicates that the deployment's phase is not suitable for rollback.
          - `incompatible_result` - indicates that the deployment's result is not suitable for rollback.
          - `exceeded_revision_limit` - indicates that the app has exceeded the rollback revision limits for its tier.
          - `app_pinned` - indicates that there is already a rollback in progress and the app is pinned.
          - `database_config_conflict` - indicates that the deployment's database config is different than the current config.
          - `region_conflict` - indicates that the deployment's region differs from the current app region.
          
        Warning conditions:
          - `static_site_requires_rebuild` - indicates that the deployment contains at least one static site that will require a rebuild.
          - `image_source_missing_digest` - indicates that the deployment contains at least one component with an image source that is missing a digest.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        A human-readable message describing the failing condition.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class AppRouteSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preservePathPrefix":
            suggest = "preserve_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppRouteSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppRouteSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppRouteSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: An HTTP path prefix. Paths must start with / and must be unique across all components within an app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component. For example, a component with `path=/api` will have requests to `/api/list` trimmed to `/list`. If this value is `true`, the path will remain `/api/list`.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        An HTTP path prefix. Paths must start with / and must be unique across all components within an app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component. For example, a component with `path=/api` will have requests to `/api/list` trimmed to `/list`. If this value is `true`, the path will remain `/api/list`.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class AppServiceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceSizeSlug":
            suggest = "instance_size_slug"
        elif key == "internalPorts":
            suggest = "internal_ports"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_command: Optional[_builtins.str] = None,
                 cors: Optional['outputs.AppsCorsPolicy'] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppVariableDefinition']] = None,
                 git: Optional['outputs.AppsGitSourceSpec'] = None,
                 github: Optional['outputs.AppsGithubSourceSpec'] = None,
                 gitlab: Optional['outputs.AppsGitlabSourceSpec'] = None,
                 health_check: Optional['outputs.AppServiceSpecHealthCheck'] = None,
                 http_port: Optional[_builtins.int] = None,
                 image: Optional['outputs.AppsImageSourceSpec'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional['AppComponentInstanceBaseInstanceSizeSlug'] = None,
                 internal_ports: Optional[Sequence[_builtins.int]] = None,
                 log_destinations: Optional['outputs.AppLogDestinationDefinition'] = None,
                 name: Optional[_builtins.str] = None,
                 routes: Optional[Sequence['outputs.AppRouteSpec']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        :param Sequence['AppVariableDefinition'] envs: A list of environment variables made available to the component.
        :param _builtins.int http_port: The internal port on which this service's run command will listen. Default: 8080
               If there is not an environment variable with the name `PORT`, one will be automatically added with its value set to the value of this field.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to. Default: 1
        :param 'AppComponentInstanceBaseInstanceSizeSlug' instance_size_slug: The instance size to use for this component. Default: `basic-xxs`
        :param Sequence[_builtins.int] internal_ports: The ports on which this service will listen for internal traffic.
        :param _builtins.str name: The name. Must be unique across all components within the same app.
        :param Sequence['AppRouteSpec'] routes: A list of HTTP routes that should be routed to this component.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is None:
            instance_size_slug = 'basic-xxs'
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if internal_ports is not None:
            pulumi.set(__self__, "internal_ports", internal_ports)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppsCorsPolicy']:
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppVariableDefinition']]:
        """
        A list of environment variables made available to the component.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppsGitSourceSpec']:
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppsGithubSourceSpec']:
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppsGitlabSourceSpec']:
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.AppServiceSpecHealthCheck']:
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        The internal port on which this service's run command will listen. Default: 8080
        If there is not an environment variable with the name `PORT`, one will be automatically added with its value set to the value of this field.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppsImageSourceSpec']:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to. Default: 1
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional['AppComponentInstanceBaseInstanceSizeSlug']:
        """
        The instance size to use for this component. Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter(name="internalPorts")
    def internal_ports(self) -> Optional[Sequence[_builtins.int]]:
        """
        The ports on which this service will listen for internal traffic.
        """
        return pulumi.get(self, "internal_ports")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional['outputs.AppLogDestinationDefinition']:
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name. Must be unique across all components within the same app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.AppRouteSpec']]:
        """
        A list of HTTP routes that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppServiceSpecHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpPath":
            suggest = "http_path"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSpecHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSpecHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSpecHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_path: Optional[_builtins.str] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int failure_threshold: The number of failed health checks before considered unhealthy.
        :param _builtins.str http_path: The route path used for the HTTP health check ping. If not set, the HTTP health check will be disabled and a TCP health check used instead.
        :param _builtins.int initial_delay_seconds: The number of seconds to wait before beginning health checks.
        :param _builtins.int period_seconds: The number of seconds to wait between health checks.
        :param _builtins.int port: The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
        :param _builtins.int success_threshold: The number of successful health checks before considered healthy.
        :param _builtins.int timeout_seconds: The number of seconds after which the check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        The number of failed health checks before considered unhealthy.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[_builtins.str]:
        """
        The route path used for the HTTP health check ping. If not set, the HTTP health check will be disabled and a TCP health check used instead.
        """
        return pulumi.get(self, "http_path")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before beginning health checks.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between health checks.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        The number of successful health checks before considered healthy.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds after which the check times out.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class AppSpec(dict):
    """
    The desired configuration of an application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticSites":
            suggest = "static_sites"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 databases: Optional[Sequence['outputs.AppDatabaseSpec']] = None,
                 domains: Optional[Sequence['outputs.AppDomainSpec']] = None,
                 functions: Optional[Sequence['outputs.AppFunctionsSpec']] = None,
                 ingress: Optional['outputs.AppIngressSpec'] = None,
                 jobs: Optional[Sequence['outputs.AppJobSpec']] = None,
                 region: Optional['AppSpecRegion'] = None,
                 services: Optional[Sequence['outputs.AppServiceSpec']] = None,
                 static_sites: Optional[Sequence['outputs.AppStaticSiteSpec']] = None,
                 workers: Optional[Sequence['outputs.AppWorkerSpec']] = None):
        """
        The desired configuration of an application.
        :param _builtins.str name: The name of the app. Must be unique across all apps in the same account.
        :param Sequence['AppDatabaseSpec'] databases: Database instances which can provide persistence to workloads within the
               application.
        :param Sequence['AppDomainSpec'] domains: A set of hostnames where the application will be available.
        :param Sequence['AppFunctionsSpec'] functions: Workloads which expose publicly-accessible HTTP services via Functions Components.
        :param 'AppIngressSpec' ingress: Specification for app ingress configurations.
        :param Sequence['AppJobSpec'] jobs: Pre and post deployment workloads which do not expose publicly-accessible HTTP routes.
        :param 'AppSpecRegion' region: The slug form of the geographical origin of the app. Default: `nearest available`
        :param Sequence['AppServiceSpec'] services: Workloads which expose publicly-accessible HTTP services.
        :param Sequence['AppStaticSiteSpec'] static_sites: Content which can be rendered to static web assets.
        :param Sequence['AppWorkerSpec'] workers: Workloads which do not expose publicly-accessible HTTP services.
        """
        pulumi.set(__self__, "name", name)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the app. Must be unique across all apps in the same account.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[Sequence['outputs.AppDatabaseSpec']]:
        """
        Database instances which can provide persistence to workloads within the
        application.
        """
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[Sequence['outputs.AppDomainSpec']]:
        """
        A set of hostnames where the application will be available.
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AppFunctionsSpec']]:
        """
        Workloads which expose publicly-accessible HTTP services via Functions Components.
        """
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.AppIngressSpec']:
        """
        Specification for app ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence['outputs.AppJobSpec']]:
        """
        Pre and post deployment workloads which do not expose publicly-accessible HTTP routes.
        """
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional['AppSpecRegion']:
        """
        The slug form of the geographical origin of the app. Default: `nearest available`
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.AppServiceSpec']]:
        """
        Workloads which expose publicly-accessible HTTP services.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[Sequence['outputs.AppStaticSiteSpec']]:
        """
        Content which can be rendered to static web assets.
        """
        return pulumi.get(self, "static_sites")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[Sequence['outputs.AppWorkerSpec']]:
        """
        Workloads which do not expose publicly-accessible HTTP services.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class AppStaticSiteSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "catchallDocument":
            suggest = "catchall_document"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "errorDocument":
            suggest = "error_document"
        elif key == "indexDocument":
            suggest = "index_document"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "outputDir":
            suggest = "output_dir"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppStaticSiteSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppStaticSiteSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppStaticSiteSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_command: Optional[_builtins.str] = None,
                 catchall_document: Optional[_builtins.str] = None,
                 cors: Optional['outputs.AppsCorsPolicy'] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppVariableDefinition']] = None,
                 error_document: Optional[_builtins.str] = None,
                 git: Optional['outputs.AppsGitSourceSpec'] = None,
                 github: Optional['outputs.AppsGithubSourceSpec'] = None,
                 gitlab: Optional['outputs.AppsGitlabSourceSpec'] = None,
                 image: Optional['outputs.AppsImageSourceSpec'] = None,
                 index_document: Optional[_builtins.str] = None,
                 log_destinations: Optional['outputs.AppLogDestinationDefinition'] = None,
                 name: Optional[_builtins.str] = None,
                 output_dir: Optional[_builtins.str] = None,
                 routes: Optional[Sequence['outputs.AppRouteSpec']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site. Only 1 of `catchall_document` or `error_document` can be set.
        :param _builtins.str dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        :param Sequence['AppVariableDefinition'] envs: A list of environment variables made available to the component.
        :param _builtins.str error_document: The name of the error document to use when serving this static site. Default: 404.html. If no such file exists within the built assets, App Platform will supply one.
        :param _builtins.str index_document: The name of the index document to use when serving this static site. Default: index.html
        :param _builtins.str name: The name. Must be unique across all components within the same app.
        :param _builtins.str output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`, `build`.
        :param Sequence['AppRouteSpec'] routes: A list of HTTP routes that should be routed to this component.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if catchall_document is not None:
            pulumi.set(__self__, "catchall_document", catchall_document)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if error_document is None:
            error_document = '404.html'
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if index_document is None:
            index_document = 'index.html'
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if output_dir is not None:
            pulumi.set(__self__, "output_dir", output_dir)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="catchallDocument")
    def catchall_document(self) -> Optional[_builtins.str]:
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site. Only 1 of `catchall_document` or `error_document` can be set.
        """
        return pulumi.get(self, "catchall_document")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppsCorsPolicy']:
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppVariableDefinition']]:
        """
        A list of environment variables made available to the component.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[_builtins.str]:
        """
        The name of the error document to use when serving this static site. Default: 404.html. If no such file exists within the built assets, App Platform will supply one.
        """
        return pulumi.get(self, "error_document")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppsGitSourceSpec']:
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppsGithubSourceSpec']:
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppsGitlabSourceSpec']:
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppsImageSourceSpec']:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[_builtins.str]:
        """
        The name of the index document to use when serving this static site. Default: index.html
        """
        return pulumi.get(self, "index_document")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional['outputs.AppLogDestinationDefinition']:
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name. Must be unique across all components within the same app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputDir")
    def output_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`, `build`.
        """
        return pulumi.get(self, "output_dir")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.AppRouteSpec']]:
        """
        A list of HTTP routes that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppVariableDefinition(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 scope: Optional['AppVariableDefinitionScope'] = None,
                 type: Optional['AppVariableDefinitionType'] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The variable name
        :param 'AppVariableDefinitionScope' scope: - RUN_TIME: Made available only at run-time
               - BUILD_TIME: Made available only at build-time
               - RUN_AND_BUILD_TIME: Made available at both build and run-time
        :param 'AppVariableDefinitionType' type: - GENERAL: A plain-text environment variable
               - SECRET: A secret encrypted environment variable
        :param _builtins.str value: The value. If the type is `SECRET`, the value will be encrypted on first submission. On following submissions, the encrypted value should be used.
        """
        pulumi.set(__self__, "key", key)
        if scope is None:
            scope = 'RUN_AND_BUILD_TIME'
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is None:
            type = 'GENERAL'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The variable name
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional['AppVariableDefinitionScope']:
        """
        - RUN_TIME: Made available only at run-time
        - BUILD_TIME: Made available only at build-time
        - RUN_AND_BUILD_TIME: Made available at both build and run-time
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['AppVariableDefinitionType']:
        """
        - GENERAL: A plain-text environment variable
        - SECRET: A secret encrypted environment variable
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value. If the type is `SECRET`, the value will be encrypted on first submission. On following submissions, the encrypted value should be used.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppWorkerSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceSizeSlug":
            suggest = "instance_size_slug"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppWorkerSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppWorkerSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppWorkerSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_command: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppVariableDefinition']] = None,
                 git: Optional['outputs.AppsGitSourceSpec'] = None,
                 github: Optional['outputs.AppsGithubSourceSpec'] = None,
                 gitlab: Optional['outputs.AppsGitlabSourceSpec'] = None,
                 image: Optional['outputs.AppsImageSourceSpec'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional['AppComponentInstanceBaseInstanceSizeSlug'] = None,
                 log_destinations: Optional['outputs.AppLogDestinationDefinition'] = None,
                 name: Optional[_builtins.str] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        :param Sequence['AppVariableDefinition'] envs: A list of environment variables made available to the component.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to. Default: 1
        :param 'AppComponentInstanceBaseInstanceSizeSlug' instance_size_slug: The instance size to use for this component. Default: `basic-xxs`
        :param _builtins.str name: The name. Must be unique across all components within the same app.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is None:
            instance_size_slug = 'basic-xxs'
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to the Dockerfile relative to the root of the repo. If set, it will be used to build this component. Otherwise, App Platform will attempt to build it using buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app. For a full list, please refer to [the product documentation](https://www.digitalocean.com/docs/app-platform/).
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppVariableDefinition']]:
        """
        A list of environment variables made available to the component.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppsGitSourceSpec']:
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppsGithubSourceSpec']:
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppsGitlabSourceSpec']:
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppsImageSourceSpec']:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to. Default: 1
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional['AppComponentInstanceBaseInstanceSizeSlug']:
        """
        The instance size to use for this component. Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional['outputs.AppLogDestinationDefinition']:
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name. Must be unique across all components within the same app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build. For Dockerfile builds, this will be used as the build context. Must be relative to the root of the repo.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppsCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence['outputs.AppsStringMatch']] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is include. This configures the `Access-Control-Allow-Credentials` header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param Sequence['AppsStringMatch'] allow_origins: The set of allowed CORS origins.
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the `Access-Control-Max-Age` header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is include. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence['outputs.AppsStringMatch']]:
        """
        The set of allowed CORS origins.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the `Access-Control-Max-Age` header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AppsDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clonedFrom":
            suggest = "cloned_from"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "phaseLastUpdatedAt":
            suggest = "phase_last_updated_at"
        elif key == "staticSites":
            suggest = "static_sites"
        elif key == "tierSlug":
            suggest = "tier_slug"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cause: Optional[_builtins.str] = None,
                 cloned_from: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 functions: Optional[Sequence['outputs.AppsDeploymentFunctions']] = None,
                 id: Optional[_builtins.str] = None,
                 jobs: Optional[Sequence['outputs.AppsDeploymentJob']] = None,
                 phase: Optional['AppsDeploymentPhase'] = None,
                 phase_last_updated_at: Optional[_builtins.str] = None,
                 progress: Optional['outputs.AppsDeploymentProgress'] = None,
                 services: Optional[Sequence['outputs.AppsDeploymentService']] = None,
                 spec: Optional['outputs.AppSpec'] = None,
                 static_sites: Optional[Sequence['outputs.AppsDeploymentStaticSite']] = None,
                 tier_slug: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 workers: Optional[Sequence['outputs.AppsDeploymentWorker']] = None):
        """
        :param 'AppSpec' spec: The desired configuration of an application.
        """
        if cause is not None:
            pulumi.set(__self__, "cause", cause)
        if cloned_from is not None:
            pulumi.set(__self__, "cloned_from", cloned_from)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if phase is None:
            phase = 'UNKNOWN'
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if phase_last_updated_at is not None:
            pulumi.set(__self__, "phase_last_updated_at", phase_last_updated_at)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if tier_slug is not None:
            pulumi.set(__self__, "tier_slug", tier_slug)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def cause(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cause")

    @_builtins.property
    @pulumi.getter(name="clonedFrom")
    def cloned_from(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloned_from")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AppsDeploymentFunctions']]:
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence['outputs.AppsDeploymentJob']]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional['AppsDeploymentPhase']:
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="phaseLastUpdatedAt")
    def phase_last_updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "phase_last_updated_at")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> Optional['outputs.AppsDeploymentProgress']:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.AppsDeploymentService']]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.AppSpec']:
        """
        The desired configuration of an application.
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[Sequence['outputs.AppsDeploymentStaticSite']]:
        return pulumi.get(self, "static_sites")

    @_builtins.property
    @pulumi.getter(name="tierSlug")
    def tier_slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_slug")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[Sequence['outputs.AppsDeploymentWorker']]:
        return pulumi.get(self, "workers")


@pulumi.output_type
class AppsDeploymentFunctions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCommitHash":
            suggest = "source_commit_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentFunctions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentFunctions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentFunctions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 source_commit_hash: Optional[_builtins.str] = None):
        """
        :param _builtins.str namespace: The namespace where the functions are deployed.
        :param _builtins.str source_commit_hash: The commit hash of the repository that was used to build this functions component.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if source_commit_hash is not None:
            pulumi.set(__self__, "source_commit_hash", source_commit_hash)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace where the functions are deployed.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="sourceCommitHash")
    def source_commit_hash(self) -> Optional[_builtins.str]:
        """
        The commit hash of the repository that was used to build this functions component.
        """
        return pulumi.get(self, "source_commit_hash")


@pulumi.output_type
class AppsDeploymentJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCommitHash":
            suggest = "source_commit_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 source_commit_hash: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_commit_hash is not None:
            pulumi.set(__self__, "source_commit_hash", source_commit_hash)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCommitHash")
    def source_commit_hash(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_commit_hash")


@pulumi.output_type
class AppsDeploymentProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorSteps":
            suggest = "error_steps"
        elif key == "pendingSteps":
            suggest = "pending_steps"
        elif key == "runningSteps":
            suggest = "running_steps"
        elif key == "successSteps":
            suggest = "success_steps"
        elif key == "summarySteps":
            suggest = "summary_steps"
        elif key == "totalSteps":
            suggest = "total_steps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_steps: Optional[_builtins.int] = None,
                 pending_steps: Optional[_builtins.int] = None,
                 running_steps: Optional[_builtins.int] = None,
                 steps: Optional[Sequence['outputs.AppsDeploymentProgressStep']] = None,
                 success_steps: Optional[_builtins.int] = None,
                 summary_steps: Optional[Sequence['outputs.AppsDeploymentProgressStep']] = None,
                 total_steps: Optional[_builtins.int] = None):
        if error_steps is not None:
            pulumi.set(__self__, "error_steps", error_steps)
        if pending_steps is not None:
            pulumi.set(__self__, "pending_steps", pending_steps)
        if running_steps is not None:
            pulumi.set(__self__, "running_steps", running_steps)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if success_steps is not None:
            pulumi.set(__self__, "success_steps", success_steps)
        if summary_steps is not None:
            pulumi.set(__self__, "summary_steps", summary_steps)
        if total_steps is not None:
            pulumi.set(__self__, "total_steps", total_steps)

    @_builtins.property
    @pulumi.getter(name="errorSteps")
    def error_steps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "error_steps")

    @_builtins.property
    @pulumi.getter(name="pendingSteps")
    def pending_steps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "pending_steps")

    @_builtins.property
    @pulumi.getter(name="runningSteps")
    def running_steps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "running_steps")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.AppsDeploymentProgressStep']]:
        return pulumi.get(self, "steps")

    @_builtins.property
    @pulumi.getter(name="successSteps")
    def success_steps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "success_steps")

    @_builtins.property
    @pulumi.getter(name="summarySteps")
    def summary_steps(self) -> Optional[Sequence['outputs.AppsDeploymentProgressStep']]:
        return pulumi.get(self, "summary_steps")

    @_builtins.property
    @pulumi.getter(name="totalSteps")
    def total_steps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_steps")


@pulumi.output_type
class AppsDeploymentProgressStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentName":
            suggest = "component_name"
        elif key == "endedAt":
            suggest = "ended_at"
        elif key == "messageBase":
            suggest = "message_base"
        elif key == "startedAt":
            suggest = "started_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentProgressStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentProgressStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentProgressStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_name: Optional[_builtins.str] = None,
                 ended_at: Optional[_builtins.str] = None,
                 message_base: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 reason: Optional['outputs.AppsDeploymentProgressStepReason'] = None,
                 started_at: Optional[_builtins.str] = None,
                 status: Optional['AppsDeploymentProgressStepStatus'] = None,
                 steps: Optional[Sequence[Any]] = None):
        """
        :param _builtins.str message_base: The base of a human-readable description of the step intended to be combined with the component name for presentation. For example:
               
               `message_base` = "Building service"
               `component_name` = "api"
        """
        if component_name is not None:
            pulumi.set(__self__, "component_name", component_name)
        if ended_at is not None:
            pulumi.set(__self__, "ended_at", ended_at)
        if message_base is not None:
            pulumi.set(__self__, "message_base", message_base)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if status is None:
            status = 'UNKNOWN'
        if status is not None:
            pulumi.set(__self__, "status", status)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter(name="componentName")
    def component_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "component_name")

    @_builtins.property
    @pulumi.getter(name="endedAt")
    def ended_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ended_at")

    @_builtins.property
    @pulumi.getter(name="messageBase")
    def message_base(self) -> Optional[_builtins.str]:
        """
        The base of a human-readable description of the step intended to be combined with the component name for presentation. For example:

        `message_base` = "Building service"
        `component_name` = "api"
        """
        return pulumi.get(self, "message_base")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional['outputs.AppsDeploymentProgressStepReason']:
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['AppsDeploymentProgressStepStatus']:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "steps")


@pulumi.output_type
class AppsDeploymentProgressStepReason(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")


@pulumi.output_type
class AppsDeploymentService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCommitHash":
            suggest = "source_commit_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 source_commit_hash: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_commit_hash is not None:
            pulumi.set(__self__, "source_commit_hash", source_commit_hash)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCommitHash")
    def source_commit_hash(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_commit_hash")


@pulumi.output_type
class AppsDeploymentStaticSite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCommitHash":
            suggest = "source_commit_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentStaticSite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentStaticSite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentStaticSite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 source_commit_hash: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_commit_hash is not None:
            pulumi.set(__self__, "source_commit_hash", source_commit_hash)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCommitHash")
    def source_commit_hash(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_commit_hash")


@pulumi.output_type
class AppsDeploymentWorker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCommitHash":
            suggest = "source_commit_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDeploymentWorker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDeploymentWorker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDeploymentWorker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 source_commit_hash: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_commit_hash is not None:
            pulumi.set(__self__, "source_commit_hash", source_commit_hash)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCommitHash")
    def source_commit_hash(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_commit_hash")


@pulumi.output_type
class AppsDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateExpiresAt":
            suggest = "certificate_expires_at"
        elif key == "rotateValidationRecords":
            suggest = "rotate_validation_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_expires_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 phase: Optional['AppsDomainPhase'] = None,
                 progress: Optional['outputs.AppsDomainProgress'] = None,
                 rotate_validation_records: Optional[_builtins.bool] = None,
                 spec: Optional['outputs.AppDomainSpec'] = None,
                 validations: Optional[Sequence['outputs.AppDomainValidation']] = None):
        if certificate_expires_at is not None:
            pulumi.set(__self__, "certificate_expires_at", certificate_expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if phase is None:
            phase = 'UNKNOWN'
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if rotate_validation_records is not None:
            pulumi.set(__self__, "rotate_validation_records", rotate_validation_records)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if validations is not None:
            pulumi.set(__self__, "validations", validations)

    @_builtins.property
    @pulumi.getter(name="certificateExpiresAt")
    def certificate_expires_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional['AppsDomainPhase']:
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> Optional['outputs.AppsDomainProgress']:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter(name="rotateValidationRecords")
    def rotate_validation_records(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "rotate_validation_records")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.AppDomainSpec']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def validations(self) -> Optional[Sequence['outputs.AppDomainValidation']]:
        return pulumi.get(self, "validations")


@pulumi.output_type
class AppsDomainProgress(dict):
    def __init__(__self__, *,
                 steps: Optional[Sequence[Any]] = None):
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "steps")


@pulumi.output_type
class AppsGitSourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoCloneUrl":
            suggest = "repo_clone_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsGitSourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsGitSourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsGitSourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use
        :param _builtins.str repo_clone_url: The clone URL of the repo. Example: `https://github.com/digitalocean/sample-golang.git`
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo. Example: `https://github.com/digitalocean/sample-golang.git`
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class AppsGithubSourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsGithubSourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsGithubSourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsGithubSourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo
        :param _builtins.str repo: The name of the repo in the format owner/repo. Example: `digitalocean/sample-golang`
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format owner/repo. Example: `digitalocean/sample-golang`
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppsGitlabSourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsGitlabSourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsGitlabSourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsGitlabSourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo
        :param _builtins.str repo: The name of the repo in the format owner/repo. Example: `digitalocean/sample-golang`
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format owner/repo. Example: `digitalocean/sample-golang`
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppsImageSourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryType":
            suggest = "registry_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsImageSourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsImageSourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsImageSourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry: Optional[_builtins.str] = None,
                 registry_type: Optional['AppsImageSourceSpecRegistryType'] = None,
                 repository: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type.
        :param 'AppsImageSourceSpecRegistryType' registry_type: - DOCKER_HUB: The DockerHub container registry type.
               - DOCR: The DigitalOcean container registry type.
        :param _builtins.str repository: The repository name.
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_type is not None:
            pulumi.set(__self__, "registry_type", registry_type)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if tag is None:
            tag = 'latest'
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> Optional['AppsImageSourceSpecRegistryType']:
        """
        - DOCKER_HUB: The DockerHub container registry type.
        - DOCR: The DigitalOcean container registry type.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> Optional[_builtins.str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class AppsInstanceSize(dict):
    def __init__(__self__, *,
                 cpu_type: Optional['AppsInstanceSizeCpuType'] = None,
                 cpus: Optional[_builtins.str] = None,
                 memory_bytes: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 slug: Optional[_builtins.str] = None,
                 tier_downgrade_to: Optional[_builtins.str] = None,
                 tier_slug: Optional[_builtins.str] = None,
                 tier_upgrade_to: Optional[_builtins.str] = None,
                 usd_per_month: Optional[_builtins.str] = None,
                 usd_per_second: Optional[_builtins.str] = None):
        if cpu_type is None:
            cpu_type = 'UNSPECIFIED'
        if cpu_type is not None:
            pulumi.set(__self__, "cpu_type", cpu_type)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if memory_bytes is not None:
            pulumi.set(__self__, "memory_bytes", memory_bytes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)
        if tier_downgrade_to is not None:
            pulumi.set(__self__, "tier_downgrade_to", tier_downgrade_to)
        if tier_slug is not None:
            pulumi.set(__self__, "tier_slug", tier_slug)
        if tier_upgrade_to is not None:
            pulumi.set(__self__, "tier_upgrade_to", tier_upgrade_to)
        if usd_per_month is not None:
            pulumi.set(__self__, "usd_per_month", usd_per_month)
        if usd_per_second is not None:
            pulumi.set(__self__, "usd_per_second", usd_per_second)

    @_builtins.property
    @pulumi.getter(name="cpuType")
    def cpu_type(self) -> Optional['AppsInstanceSizeCpuType']:
        return pulumi.get(self, "cpu_type")

    @_builtins.property
    @pulumi.getter
    def cpus(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cpus")

    @_builtins.property
    @pulumi.getter(name="memoryBytes")
    def memory_bytes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "memory_bytes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slug")

    @_builtins.property
    @pulumi.getter(name="tierDowngradeTo")
    def tier_downgrade_to(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_downgrade_to")

    @_builtins.property
    @pulumi.getter(name="tierSlug")
    def tier_slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_slug")

    @_builtins.property
    @pulumi.getter(name="tierUpgradeTo")
    def tier_upgrade_to(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tier_upgrade_to")

    @_builtins.property
    @pulumi.getter(name="usdPerMonth")
    def usd_per_month(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "usd_per_month")

    @_builtins.property
    @pulumi.getter(name="usdPerSecond")
    def usd_per_second(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "usd_per_second")


@pulumi.output_type
class AppsRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCenters":
            suggest = "data_centers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continent: Optional[_builtins.str] = None,
                 data_centers: Optional[Sequence[_builtins.str]] = None,
                 default: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 flag: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 reason: Optional[_builtins.str] = None,
                 slug: Optional[_builtins.str] = None):
        """
        :param _builtins.bool default: Whether or not the region is presented as the default.
        """
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if data_centers is not None:
            pulumi.set(__self__, "data_centers", data_centers)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if flag is not None:
            pulumi.set(__self__, "flag", flag)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter(name="dataCenters")
    def data_centers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "data_centers")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.bool]:
        """
        Whether or not the region is presented as the default.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def flag(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "flag")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class AppsStringMatch(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Exact string match. Only 1 of `exact`, `prefix`, or `regex` must be set.
        :param _builtins.str prefix: Prefix-based match. Only 1 of `exact`, `prefix`, or `regex` must be set.
        :param _builtins.str regex: RE2 style regex-based match. Only 1 of `exact`, `prefix`, or `regex` must be set. For more information about RE2 syntax, see: https://github.com/google/re2/wiki/Syntax
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact string match. Only 1 of `exact`, `prefix`, or `regex` must be set.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix-based match. Only 1 of `exact`, `prefix`, or `regex` must be set.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        RE2 style regex-based match. Only 1 of `exact`, `prefix`, or `regex` must be set. For more information about RE2 syntax, see: https://github.com/google/re2/wiki/Syntax
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AppsTier(dict):
    def __init__(__self__, *,
                 build_seconds: Optional[_builtins.str] = None,
                 egress_bandwidth_bytes: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 slug: Optional[_builtins.str] = None,
                 storage_bytes: Optional[_builtins.str] = None):
        if build_seconds is not None:
            pulumi.set(__self__, "build_seconds", build_seconds)
        if egress_bandwidth_bytes is not None:
            pulumi.set(__self__, "egress_bandwidth_bytes", egress_bandwidth_bytes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)
        if storage_bytes is not None:
            pulumi.set(__self__, "storage_bytes", storage_bytes)

    @_builtins.property
    @pulumi.getter(name="buildSeconds")
    def build_seconds(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "build_seconds")

    @_builtins.property
    @pulumi.getter(name="egressBandwidthBytes")
    def egress_bandwidth_bytes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_bandwidth_bytes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slug")

    @_builtins.property
    @pulumi.getter(name="storageBytes")
    def storage_bytes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_bytes")


@pulumi.output_type
class Error(dict):
    def __init__(__self__, *,
                 code: Optional['AppRollbackValidationConditionCode'] = None,
                 components: Optional[Sequence[_builtins.str]] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param 'AppRollbackValidationConditionCode' code: A code identifier that represents the failing condition.
               
               Failing conditions:
                 - `incompatible_phase` - indicates that the deployment's phase is not suitable for rollback.
                 - `incompatible_result` - indicates that the deployment's result is not suitable for rollback.
                 - `exceeded_revision_limit` - indicates that the app has exceeded the rollback revision limits for its tier.
                 - `app_pinned` - indicates that there is already a rollback in progress and the app is pinned.
                 - `database_config_conflict` - indicates that the deployment's database config is different than the current config.
                 - `region_conflict` - indicates that the deployment's region differs from the current app region.
                 
               Warning conditions:
                 - `static_site_requires_rebuild` - indicates that the deployment contains at least one static site that will require a rebuild.
                 - `image_source_missing_digest` - indicates that the deployment contains at least one component with an image source that is missing a digest.
        :param _builtins.str message: A human-readable message describing the failing condition.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional['AppRollbackValidationConditionCode']:
        """
        A code identifier that represents the failing condition.

        Failing conditions:
          - `incompatible_phase` - indicates that the deployment's phase is not suitable for rollback.
          - `incompatible_result` - indicates that the deployment's result is not suitable for rollback.
          - `exceeded_revision_limit` - indicates that the app has exceeded the rollback revision limits for its tier.
          - `app_pinned` - indicates that there is already a rollback in progress and the app is pinned.
          - `database_config_conflict` - indicates that the deployment's database config is different than the current config.
          - `region_conflict` - indicates that the deployment's region differs from the current app region.
          
        Warning conditions:
          - `static_site_requires_rebuild` - indicates that the deployment contains at least one static site that will require a rebuild.
          - `image_source_missing_digest` - indicates that the deployment contains at least one component with an image source that is missing a digest.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        A human-readable message describing the failing condition.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class MetaMeta(dict):
    def __init__(__self__, *,
                 total: Optional[_builtins.int] = None):
        """
        :param _builtins.int total: Number of objects returned by the request.
        """
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[_builtins.int]:
        """
        Number of objects returned by the request.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class PageLinks(dict):
    def __init__(__self__, *,
                 pages: Optional['outputs.PageLinksPagesProperties'] = None):
        if pages is not None:
            pulumi.set(__self__, "pages", pages)

    @_builtins.property
    @pulumi.getter
    def pages(self) -> Optional['outputs.PageLinksPagesProperties']:
        return pulumi.get(self, "pages")


@pulumi.output_type
class PageLinksPagesProperties(dict):
    def __init__(__self__, *,
                 first: Optional[_builtins.str] = None,
                 last: Optional[_builtins.str] = None,
                 next: Optional[_builtins.str] = None,
                 prev: Optional[_builtins.str] = None):
        if first is not None:
            pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if next is not None:
            pulumi.set(__self__, "next", next)
        if prev is not None:
            pulumi.set(__self__, "prev", prev)

    @_builtins.property
    @pulumi.getter
    def first(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "first")

    @_builtins.property
    @pulumi.getter
    def last(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last")

    @_builtins.property
    @pulumi.getter
    def next(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "next")

    @_builtins.property
    @pulumi.getter
    def prev(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prev")


