# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ForwardingRule',
    'GetLoadBalancerProperties',
    'HealthCheck',
    'LbFirewall',
    'ListLoadBalancersItems',
    'LoadBalancer',
    'MetaMeta',
    'PageLinks',
    'PageLinksPagesProperties',
    'StickySessions',
]

@pulumi.output_type
class ForwardingRule(dict):
    """
    An object specifying a forwarding rule for a load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPort":
            suggest = "entry_port"
        elif key == "entryProtocol":
            suggest = "entry_protocol"
        elif key == "targetPort":
            suggest = "target_port"
        elif key == "targetProtocol":
            suggest = "target_protocol"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "tlsPassthrough":
            suggest = "tls_passthrough"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForwardingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForwardingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForwardingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_port: int,
                 entry_protocol: 'ForwardingRuleEntryProtocol',
                 target_port: int,
                 target_protocol: 'ForwardingRuleTargetProtocol',
                 certificate_id: Optional[str] = None,
                 tls_passthrough: Optional[bool] = None):
        """
        An object specifying a forwarding rule for a load balancer.
        :param int entry_port: An integer representing the port on which the load balancer instance will listen.
        :param 'ForwardingRuleEntryProtocol' entry_protocol: The protocol used for traffic to the load balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`. If you set the  `entry_protocol` to `udp`, the `target_protocol` must be set to `udp`.  When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
        :param int target_port: An integer representing the port on the backend Droplets to which the load balancer will send traffic.
        :param 'ForwardingRuleTargetProtocol' target_protocol: The protocol used for traffic from the load balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`. If you set the `target_protocol` to `udp`, the `entry_protocol` must be set to  `udp`. When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
        :param str certificate_id: The ID of the TLS certificate used for SSL termination if enabled.
        :param bool tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets.
        """
        pulumi.set(__self__, "entry_port", entry_port)
        pulumi.set(__self__, "entry_protocol", entry_protocol)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if tls_passthrough is not None:
            pulumi.set(__self__, "tls_passthrough", tls_passthrough)

    @property
    @pulumi.getter(name="entryPort")
    def entry_port(self) -> int:
        """
        An integer representing the port on which the load balancer instance will listen.
        """
        return pulumi.get(self, "entry_port")

    @property
    @pulumi.getter(name="entryProtocol")
    def entry_protocol(self) -> 'ForwardingRuleEntryProtocol':
        """
        The protocol used for traffic to the load balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`. If you set the  `entry_protocol` to `udp`, the `target_protocol` must be set to `udp`.  When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
        """
        return pulumi.get(self, "entry_protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> int:
        """
        An integer representing the port on the backend Droplets to which the load balancer will send traffic.
        """
        return pulumi.get(self, "target_port")

    @property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> 'ForwardingRuleTargetProtocol':
        """
        The protocol used for traffic from the load balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`. If you set the `target_protocol` to `udp`, the `entry_protocol` must be set to  `udp`. When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
        """
        return pulumi.get(self, "target_protocol")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        """
        The ID of the TLS certificate used for SSL termination if enabled.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter(name="tlsPassthrough")
    def tls_passthrough(self) -> Optional[bool]:
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets.
        """
        return pulumi.get(self, "tls_passthrough")


@pulumi.output_type
class GetLoadBalancerProperties(dict):
    def __init__(__self__, *,
                 load_balancer: Optional['outputs.LoadBalancer'] = None):
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.LoadBalancer']:
        return pulumi.get(self, "load_balancer")


@pulumi.output_type
class HealthCheck(dict):
    """
    An object specifying health check settings for the load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkIntervalSeconds":
            suggest = "check_interval_seconds"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "responseTimeoutSeconds":
            suggest = "response_timeout_seconds"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_interval_seconds: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional['HealthCheckProtocol'] = None,
                 response_timeout_seconds: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        An object specifying health check settings for the load balancer.
        :param int check_interval_seconds: The number of seconds between between two consecutive health checks.
        :param int healthy_threshold: The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool.
        :param str path: The path on the backend Droplets to which the load balancer instance will send a request.
        :param int port: An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        :param 'HealthCheckProtocol' protocol: The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.
        :param int response_timeout_seconds: The number of seconds the load balancer instance will wait for a response until marking a health check as failed.
        :param int unhealthy_threshold: The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool.
        """
        if check_interval_seconds is None:
            check_interval_seconds = 10
        if check_interval_seconds is not None:
            pulumi.set(__self__, "check_interval_seconds", check_interval_seconds)
        if healthy_threshold is None:
            healthy_threshold = 3
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is None:
            path = '/'
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is None:
            port = 80
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is None:
            protocol = 'http'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if response_timeout_seconds is None:
            response_timeout_seconds = 5
        if response_timeout_seconds is not None:
            pulumi.set(__self__, "response_timeout_seconds", response_timeout_seconds)
        if unhealthy_threshold is None:
            unhealthy_threshold = 5
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="checkIntervalSeconds")
    def check_interval_seconds(self) -> Optional[int]:
        """
        The number of seconds between between two consecutive health checks.
        """
        return pulumi.get(self, "check_interval_seconds")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path on the backend Droplets to which the load balancer instance will send a request.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional['HealthCheckProtocol']:
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="responseTimeoutSeconds")
    def response_timeout_seconds(self) -> Optional[int]:
        """
        The number of seconds the load balancer instance will wait for a response until marking a health check as failed.
        """
        return pulumi.get(self, "response_timeout_seconds")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class LbFirewall(dict):
    """
    An object specifying allow and deny rules to control traffic to the load balancer.
    """
    def __init__(__self__, *,
                 allow: Optional[Sequence[str]] = None,
                 deny: Optional[Sequence[str]] = None):
        """
        An object specifying allow and deny rules to control traffic to the load balancer.
        :param Sequence[str] allow: the rules for allowing traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        :param Sequence[str] deny: the rules for denying traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if deny is not None:
            pulumi.set(__self__, "deny", deny)

    @property
    @pulumi.getter
    def allow(self) -> Optional[Sequence[str]]:
        """
        the rules for allowing traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def deny(self) -> Optional[Sequence[str]]:
        """
        the rules for denying traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        """
        return pulumi.get(self, "deny")


@pulumi.output_type
class ListLoadBalancersItems(dict):
    def __init__(__self__, *,
                 meta: 'outputs.MetaMeta',
                 links: Optional['outputs.PageLinks'] = None,
                 load_balancers: Optional[Sequence['outputs.LoadBalancer']] = None):
        pulumi.set(__self__, "meta", meta)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.MetaMeta':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def links(self) -> Optional['outputs.PageLinks']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.LoadBalancer']]:
        return pulumi.get(self, "load_balancers")


@pulumi.output_type
class LoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardingRules":
            suggest = "forwarding_rules"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "disableLetsEncryptDnsRecords":
            suggest = "disable_lets_encrypt_dns_records"
        elif key == "enableBackendKeepalive":
            suggest = "enable_backend_keepalive"
        elif key == "enableProxyProtocol":
            suggest = "enable_proxy_protocol"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "httpIdleTimeoutSeconds":
            suggest = "http_idle_timeout_seconds"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "redirectHttpToHttps":
            suggest = "redirect_http_to_https"
        elif key == "sizeUnit":
            suggest = "size_unit"
        elif key == "stickySessions":
            suggest = "sticky_sessions"
        elif key == "vpcUuid":
            suggest = "vpc_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forwarding_rules: Sequence['outputs.ForwardingRule'],
                 algorithm: Optional['LoadBalancerBaseAlgorithm'] = None,
                 created_at: Optional[str] = None,
                 disable_lets_encrypt_dns_records: Optional[bool] = None,
                 enable_backend_keepalive: Optional[bool] = None,
                 enable_proxy_protocol: Optional[bool] = None,
                 firewall: Optional['outputs.LbFirewall'] = None,
                 health_check: Optional['outputs.HealthCheck'] = None,
                 http_idle_timeout_seconds: Optional[int] = None,
                 id: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 project_id: Optional[str] = None,
                 redirect_http_to_https: Optional[bool] = None,
                 size: Optional['LoadBalancerBaseSize'] = None,
                 size_unit: Optional[int] = None,
                 status: Optional['LoadBalancerBaseStatus'] = None,
                 sticky_sessions: Optional['outputs.StickySessions'] = None,
                 tag: Optional[str] = None,
                 vpc_uuid: Optional[str] = None):
        """
        :param Sequence['ForwardingRule'] forwarding_rules: An array of objects specifying the forwarding rules for a load balancer.
        :param 'LoadBalancerBaseAlgorithm' algorithm: This field has been deprecated. You can no longer specify an algorithm for load balancers.
        :param str created_at: A time value given in ISO8601 combined date and time format that represents when the load balancer was created.
        :param bool disable_lets_encrypt_dns_records: A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer.
        :param bool enable_backend_keepalive: A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.
        :param bool enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
        :param 'LbFirewall' firewall: An object specifying allow and deny rules to control traffic to the load balancer.
        :param 'HealthCheck' health_check: An object specifying health check settings for the load balancer.
        :param int http_idle_timeout_seconds: An integer value which configures the idle timeout for HTTP requests to the target droplets.
        :param str id: A unique ID that can be used to identify and reference a load balancer.
        :param str ip: An attribute containing the public-facing IP address of the load balancer.
        :param str name: A human-readable name for a load balancer instance.
        :param str project_id: The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project. If an invalid project ID is provided, the load balancer will not be created.
        :param bool redirect_http_to_https: A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.
        :param 'LoadBalancerBaseSize' size: This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes.
               * `lb-small` = 1 node
               * `lb-medium` = 3 nodes
               * `lb-large` = 6 nodes
               
               You can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.
        :param int size_unit: How many nodes the load balancer contains. Each additional node increases the load balancer's ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.
        :param 'LoadBalancerBaseStatus' status: A status string indicating the current state of the load balancer. This can be `new`, `active`, or `errored`.
        :param 'StickySessions' sticky_sessions: An object specifying sticky sessions settings for the load balancer.
        :param str tag: The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
        :param str vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is assigned.
        """
        pulumi.set(__self__, "forwarding_rules", forwarding_rules)
        if algorithm is None:
            algorithm = 'round_robin'
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if disable_lets_encrypt_dns_records is None:
            disable_lets_encrypt_dns_records = False
        if disable_lets_encrypt_dns_records is not None:
            pulumi.set(__self__, "disable_lets_encrypt_dns_records", disable_lets_encrypt_dns_records)
        if enable_backend_keepalive is None:
            enable_backend_keepalive = False
        if enable_backend_keepalive is not None:
            pulumi.set(__self__, "enable_backend_keepalive", enable_backend_keepalive)
        if enable_proxy_protocol is None:
            enable_proxy_protocol = False
        if enable_proxy_protocol is not None:
            pulumi.set(__self__, "enable_proxy_protocol", enable_proxy_protocol)
        if firewall is not None:
            pulumi.set(__self__, "firewall", firewall)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if http_idle_timeout_seconds is None:
            http_idle_timeout_seconds = 60
        if http_idle_timeout_seconds is not None:
            pulumi.set(__self__, "http_idle_timeout_seconds", http_idle_timeout_seconds)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if redirect_http_to_https is None:
            redirect_http_to_https = False
        if redirect_http_to_https is not None:
            pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        if size is None:
            size = 'lb-small'
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_unit is None:
            size_unit = 1
        if size_unit is not None:
            pulumi.set(__self__, "size_unit", size_unit)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if sticky_sessions is not None:
            pulumi.set(__self__, "sticky_sessions", sticky_sessions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if vpc_uuid is not None:
            pulumi.set(__self__, "vpc_uuid", vpc_uuid)

    @property
    @pulumi.getter(name="forwardingRules")
    def forwarding_rules(self) -> Sequence['outputs.ForwardingRule']:
        """
        An array of objects specifying the forwarding rules for a load balancer.
        """
        return pulumi.get(self, "forwarding_rules")

    @property
    @pulumi.getter
    def algorithm(self) -> Optional['LoadBalancerBaseAlgorithm']:
        """
        This field has been deprecated. You can no longer specify an algorithm for load balancers.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        A time value given in ISO8601 combined date and time format that represents when the load balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="disableLetsEncryptDnsRecords")
    def disable_lets_encrypt_dns_records(self) -> Optional[bool]:
        """
        A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer.
        """
        return pulumi.get(self, "disable_lets_encrypt_dns_records")

    @property
    @pulumi.getter(name="enableBackendKeepalive")
    def enable_backend_keepalive(self) -> Optional[bool]:
        """
        A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.
        """
        return pulumi.get(self, "enable_backend_keepalive")

    @property
    @pulumi.getter(name="enableProxyProtocol")
    def enable_proxy_protocol(self) -> Optional[bool]:
        """
        A boolean value indicating whether PROXY Protocol is in use.
        """
        return pulumi.get(self, "enable_proxy_protocol")

    @property
    @pulumi.getter
    def firewall(self) -> Optional['outputs.LbFirewall']:
        """
        An object specifying allow and deny rules to control traffic to the load balancer.
        """
        return pulumi.get(self, "firewall")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.HealthCheck']:
        """
        An object specifying health check settings for the load balancer.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="httpIdleTimeoutSeconds")
    def http_idle_timeout_seconds(self) -> Optional[int]:
        """
        An integer value which configures the idle timeout for HTTP requests to the target droplets.
        """
        return pulumi.get(self, "http_idle_timeout_seconds")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A unique ID that can be used to identify and reference a load balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        An attribute containing the public-facing IP address of the load balancer.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A human-readable name for a load balancer instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project. If an invalid project ID is provided, the load balancer will not be created.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> Optional[bool]:
        """
        A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @property
    @pulumi.getter
    def size(self) -> Optional['LoadBalancerBaseSize']:
        """
        This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes.
        * `lb-small` = 1 node
        * `lb-medium` = 3 nodes
        * `lb-large` = 6 nodes

        You can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> Optional[int]:
        """
        How many nodes the load balancer contains. Each additional node increases the load balancer's ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.
        """
        return pulumi.get(self, "size_unit")

    @property
    @pulumi.getter
    def status(self) -> Optional['LoadBalancerBaseStatus']:
        """
        A status string indicating the current state of the load balancer. This can be `new`, `active`, or `errored`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> Optional['outputs.StickySessions']:
        """
        An object specifying sticky sessions settings for the load balancer.
        """
        return pulumi.get(self, "sticky_sessions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> Optional[str]:
        """
        A string specifying the UUID of the VPC to which the load balancer is assigned.
        """
        return pulumi.get(self, "vpc_uuid")


@pulumi.output_type
class MetaMeta(dict):
    def __init__(__self__, *,
                 total: Optional[int] = None):
        """
        :param int total: Number of objects returned by the request.
        """
        if total is not None:
            pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def total(self) -> Optional[int]:
        """
        Number of objects returned by the request.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class PageLinks(dict):
    def __init__(__self__, *,
                 pages: Optional['outputs.PageLinksPagesProperties'] = None):
        if pages is not None:
            pulumi.set(__self__, "pages", pages)

    @property
    @pulumi.getter
    def pages(self) -> Optional['outputs.PageLinksPagesProperties']:
        return pulumi.get(self, "pages")


@pulumi.output_type
class PageLinksPagesProperties(dict):
    def __init__(__self__, *,
                 first: Optional[str] = None,
                 last: Optional[str] = None,
                 next: Optional[str] = None,
                 prev: Optional[str] = None):
        if first is not None:
            pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if next is not None:
            pulumi.set(__self__, "next", next)
        if prev is not None:
            pulumi.set(__self__, "prev", prev)

    @property
    @pulumi.getter
    def first(self) -> Optional[str]:
        return pulumi.get(self, "first")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def next(self) -> Optional[str]:
        return pulumi.get(self, "next")

    @property
    @pulumi.getter
    def prev(self) -> Optional[str]:
        return pulumi.get(self, "prev")


@pulumi.output_type
class StickySessions(dict):
    """
    An object specifying sticky sessions settings for the load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieName":
            suggest = "cookie_name"
        elif key == "cookieTtlSeconds":
            suggest = "cookie_ttl_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StickySessions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StickySessions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StickySessions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_name: Optional[str] = None,
                 cookie_ttl_seconds: Optional[int] = None,
                 type: Optional['StickySessionsType'] = None):
        """
        An object specifying sticky sessions settings for the load balancer.
        :param str cookie_name: The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.
        :param int cookie_ttl_seconds: The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.
        :param 'StickySessionsType' type: An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if cookie_ttl_seconds is not None:
            pulumi.set(__self__, "cookie_ttl_seconds", cookie_ttl_seconds)
        if type is None:
            type = 'none'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[str]:
        """
        The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_name")

    @property
    @pulumi.getter(name="cookieTtlSeconds")
    def cookie_ttl_seconds(self) -> Optional[int]:
        """
        The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_ttl_seconds")

    @property
    @pulumi.getter
    def type(self) -> Optional['StickySessionsType']:
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.
        """
        return pulumi.get(self, "type")


