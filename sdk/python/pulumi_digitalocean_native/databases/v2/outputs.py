# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'Backup',
    'Ca',
    'Connection',
    'ConnectionPool',
    'ConnectionPoolConnection',
    'ConnectionPoolPrivateConnection',
    'Database',
    'DatabaseBackup',
    'DatabaseCluster',
    'DatabaseClusterConnection',
    'DatabaseClusterMaintenanceWindow',
    'DatabaseClusterPrivateConnection',
    'DatabaseLayoutOption',
    'DatabaseReplica',
    'DatabaseReplicaConnection',
    'DatabaseReplicaPrivateConnection',
    'DatabaseUser',
    'DatabaseVersionAvailability',
    'FirewallRule',
    'Mysql',
    'MysqlSettings',
    'OptionsOptionsProperties',
    'OptionsOptionsPropertiesMongodb',
    'OptionsOptionsPropertiesMysql',
    'OptionsOptionsPropertiesPg',
    'OptionsOptionsPropertiesRedis',
    'OptionsVersionAvailabilityProperties',
    'Pgbouncer',
    'Postgres',
    'PrivateConnection',
    'Redis',
    'SourceProperties',
    'Timescaledb',
]

@pulumi.output_type
class Backup(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 size_gigabytes: _builtins.float):
        """
        :param _builtins.str created_at: A time value given in ISO8601 combined date and time format at which the backup was created.
        :param _builtins.float size_gigabytes: The size of the database backup in GBs.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "size_gigabytes", size_gigabytes)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        A time value given in ISO8601 combined date and time format at which the backup was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="sizeGigabytes")
    def size_gigabytes(self) -> _builtins.float:
        """
        The size of the database backup in GBs.
        """
        return pulumi.get(self, "size_gigabytes")


@pulumi.output_type
class Ca(dict):
    def __init__(__self__, *,
                 certificate: _builtins.str):
        """
        :param _builtins.str certificate: base64 encoding of the certificate used to secure database connections
        """
        pulumi.set(__self__, "certificate", certificate)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> _builtins.str:
        """
        base64 encoding of the certificate used to secure database connections
        """
        return pulumi.get(self, "certificate")


@pulumi.output_type
class Connection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ConnectionPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateConnection":
            suggest = "private_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db: _builtins.str,
                 mode: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.int,
                 connection: Optional['outputs.ConnectionPoolConnection'] = None,
                 private_connection: Optional['outputs.ConnectionPoolPrivateConnection'] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str db: The database for use with the connection pool.
        :param _builtins.str mode: The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
        :param _builtins.str name: A unique name for the connection pool. Must be between 3 and 60 characters.
        :param _builtins.int size: The desired size of the PGBouncer connection pool. The maximum allowed size is determined by the size of the cluster's primary node. 25 backend server connections are allowed for every 1GB of RAM. Three are reserved for maintenance. For example, a primary node with 1 GB of RAM allows for a maximum of 22 backend server connections while one with 4 GB would allow for 97. Note that these are shared across all connection pools in a cluster.
        :param _builtins.str user: The name of the user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
        """
        pulumi.set(__self__, "db", db)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if private_connection is not None:
            pulumi.set(__self__, "private_connection", private_connection)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def db(self) -> _builtins.str:
        """
        The database for use with the connection pool.
        """
        return pulumi.get(self, "db")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A unique name for the connection pool. Must be between 3 and 60 characters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The desired size of the PGBouncer connection pool. The maximum allowed size is determined by the size of the cluster's primary node. 25 backend server connections are allowed for every 1GB of RAM. Three are reserved for maintenance. For example, a primary node with 1 GB of RAM allows for a maximum of 22 backend server connections while one with 4 GB would allow for 97. Note that these are shared across all connection pools in a cluster.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.ConnectionPoolConnection']:
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="privateConnection")
    def private_connection(self) -> Optional['outputs.ConnectionPoolPrivateConnection']:
        return pulumi.get(self, "private_connection")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The name of the user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ConnectionPoolConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ConnectionPoolPrivateConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class Database(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DatabaseBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "backupCreatedAt":
            suggest = "backup_created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 backup_created_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_name: The name of an existing database cluster from which the backup will be restored.
        :param _builtins.str backup_created_at: The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
        """
        pulumi.set(__self__, "database_name", database_name)
        if backup_created_at is not None:
            pulumi.set(__self__, "backup_created_at", backup_created_at)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of an existing database cluster from which the backup will be restored.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="backupCreatedAt")
    def backup_created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
        """
        return pulumi.get(self, "backup_created_at")


@pulumi.output_type
class DatabaseCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numNodes":
            suggest = "num_nodes"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "dbNames":
            suggest = "db_names"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "privateConnection":
            suggest = "private_connection"
        elif key == "privateNetworkUuid":
            suggest = "private_network_uuid"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "semanticVersion":
            suggest = "semantic_version"
        elif key == "versionEndOfAvailability":
            suggest = "version_end_of_availability"
        elif key == "versionEndOfLife":
            suggest = "version_end_of_life"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine: 'DatabaseClusterEngine',
                 name: _builtins.str,
                 num_nodes: _builtins.int,
                 region: _builtins.str,
                 size: _builtins.str,
                 connection: Optional['outputs.DatabaseClusterConnection'] = None,
                 created_at: Optional[_builtins.str] = None,
                 db_names: Optional[Sequence[_builtins.str]] = None,
                 id: Optional[_builtins.str] = None,
                 maintenance_window: Optional['outputs.DatabaseClusterMaintenanceWindow'] = None,
                 private_connection: Optional['outputs.DatabaseClusterPrivateConnection'] = None,
                 private_network_uuid: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 rules: Optional[Sequence['outputs.FirewallRule']] = None,
                 semantic_version: Optional[_builtins.str] = None,
                 status: Optional['DatabaseClusterStatus'] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 users: Optional[Sequence['outputs.DatabaseUser']] = None,
                 version: Optional[_builtins.str] = None,
                 version_end_of_availability: Optional[_builtins.str] = None,
                 version_end_of_life: Optional[_builtins.str] = None):
        """
        :param 'DatabaseClusterEngine' engine: A slug representing the database engine used for the cluster. The possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb" for MongoDB.
        :param _builtins.str name: A unique, human-readable name referring to a database cluster.
        :param _builtins.int num_nodes: The number of nodes in the database cluster.
        :param _builtins.str region: The slug identifier for the region where the database cluster is located.
        :param _builtins.str size: The slug identifier representing the size of the nodes in the database cluster.
        :param _builtins.str created_at: A time value given in ISO8601 combined date and time format that represents when the database cluster was created.
        :param Sequence[_builtins.str] db_names: An array of strings containing the names of databases created in the database cluster.
        :param _builtins.str id: A unique ID that can be used to identify and reference a database cluster.
        :param _builtins.str private_network_uuid: A string specifying the UUID of the VPC to which the database cluster will be assigned. If excluded, the cluster when creating a new database cluster, it will be assigned to your account's default VPC for the region.
        :param _builtins.str project_id: The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
        :param _builtins.str semantic_version: A string representing the semantic version of the database engine in use for the cluster.
        :param 'DatabaseClusterStatus' status: A string representing the current status of the database cluster.
        :param Sequence[_builtins.str] tags: An array of tags that have been applied to the database cluster.
        :param _builtins.str version: A string representing the version of the database engine in use for the cluster.
        :param _builtins.str version_end_of_availability: A timestamp referring to the date when the particular version will no longer be available for creating new clusters. If null, the version does not have an end of availability timeline.
        :param _builtins.str version_end_of_life: A timestamp referring to the date when the particular version will no longer be supported. If null, the version does not have an end of life timeline.
        """
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_nodes", num_nodes)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "size", size)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if db_names is not None:
            pulumi.set(__self__, "db_names", db_names)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if private_connection is not None:
            pulumi.set(__self__, "private_connection", private_connection)
        if private_network_uuid is not None:
            pulumi.set(__self__, "private_network_uuid", private_network_uuid)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if semantic_version is not None:
            pulumi.set(__self__, "semantic_version", semantic_version)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_end_of_availability is not None:
            pulumi.set(__self__, "version_end_of_availability", version_end_of_availability)
        if version_end_of_life is not None:
            pulumi.set(__self__, "version_end_of_life", version_end_of_life)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> 'DatabaseClusterEngine':
        """
        A slug representing the database engine used for the cluster. The possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb" for MongoDB.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A unique, human-readable name referring to a database cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="numNodes")
    def num_nodes(self) -> _builtins.int:
        """
        The number of nodes in the database cluster.
        """
        return pulumi.get(self, "num_nodes")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The slug identifier for the region where the database cluster is located.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The slug identifier representing the size of the nodes in the database cluster.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatabaseClusterConnection']:
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        A time value given in ISO8601 combined date and time format that represents when the database cluster was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dbNames")
    def db_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of databases created in the database cluster.
        """
        return pulumi.get(self, "db_names")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference a database cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.DatabaseClusterMaintenanceWindow']:
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="privateConnection")
    def private_connection(self) -> Optional['outputs.DatabaseClusterPrivateConnection']:
        return pulumi.get(self, "private_connection")

    @_builtins.property
    @pulumi.getter(name="privateNetworkUuid")
    def private_network_uuid(self) -> Optional[_builtins.str]:
        """
        A string specifying the UUID of the VPC to which the database cluster will be assigned. If excluded, the cluster when creating a new database cluster, it will be assigned to your account's default VPC for the region.
        """
        return pulumi.get(self, "private_network_uuid")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.FirewallRule']]:
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="semanticVersion")
    def semantic_version(self) -> Optional[_builtins.str]:
        """
        A string representing the semantic version of the database engine in use for the cluster.
        """
        return pulumi.get(self, "semantic_version")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['DatabaseClusterStatus']:
        """
        A string representing the current status of the database cluster.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of tags that have been applied to the database cluster.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.DatabaseUser']]:
        return pulumi.get(self, "users")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        A string representing the version of the database engine in use for the cluster.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionEndOfAvailability")
    def version_end_of_availability(self) -> Optional[_builtins.str]:
        """
        A timestamp referring to the date when the particular version will no longer be available for creating new clusters. If null, the version does not have an end of availability timeline.
        """
        return pulumi.get(self, "version_end_of_availability")

    @_builtins.property
    @pulumi.getter(name="versionEndOfLife")
    def version_end_of_life(self) -> Optional[_builtins.str]:
        """
        A timestamp referring to the date when the particular version will no longer be supported. If null, the version does not have an end of life timeline.
        """
        return pulumi.get(self, "version_end_of_life")


@pulumi.output_type
class DatabaseClusterConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatabaseClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.str,
                 description: Optional[Sequence[_builtins.str]] = None,
                 pending: Optional[_builtins.bool] = None):
        """
        :param _builtins.str day: The day of the week on which to apply maintenance updates.
        :param _builtins.str hour: The hour in UTC at which maintenance updates will be applied in 24 hour format.
        :param Sequence[_builtins.str] description: A list of strings, each containing information about a pending maintenance update.
        :param _builtins.bool pending: A boolean value indicating whether any maintenance is scheduled to be performed in the next window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pending is not None:
            pulumi.set(__self__, "pending", pending)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day of the week on which to apply maintenance updates.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.str:
        """
        The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of strings, each containing information about a pending maintenance update.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def pending(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating whether any maintenance is scheduled to be performed in the next window.
        """
        return pulumi.get(self, "pending")


@pulumi.output_type
class DatabaseClusterPrivateConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatabaseLayoutOption(dict):
    def __init__(__self__, *,
                 num_nodes: Optional[_builtins.int] = None,
                 sizes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] sizes: An array of objects containing the slugs available with various node counts
        """
        if num_nodes is not None:
            pulumi.set(__self__, "num_nodes", num_nodes)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @_builtins.property
    @pulumi.getter(name="numNodes")
    def num_nodes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_nodes")

    @_builtins.property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of objects containing the slugs available with various node counts
        """
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DatabaseReplica(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "privateConnection":
            suggest = "private_connection"
        elif key == "privateNetworkUuid":
            suggest = "private_network_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseReplica. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseReplica.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseReplica.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 connection: Optional['outputs.DatabaseReplicaConnection'] = None,
                 created_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 private_connection: Optional['outputs.DatabaseReplicaPrivateConnection'] = None,
                 private_network_uuid: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 status: Optional['DatabaseReplicaStatus'] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The name to give the read-only replicating
        :param _builtins.str created_at: A time value given in ISO8601 combined date and time format that represents when the database cluster was created.
        :param _builtins.str id: A unique ID that can be used to identify and reference a database replica.
        :param _builtins.str private_network_uuid: A string specifying the UUID of the VPC to which the read-only replica will be assigned. If excluded, the replica will be assigned to your account's default VPC for the region.
        :param _builtins.str region: A slug identifier for the region where the read-only replica will be located. If excluded, the replica will be placed in the same region as the cluster.
        :param _builtins.str size: A slug identifier representing the size of the node for the read-only replica. The size of the replica must be at least as large as the node size for the database cluster from which it is replicating.
        :param 'DatabaseReplicaStatus' status: A string representing the current status of the database cluster.
        :param Sequence[_builtins.str] tags: A flat array of tag names as strings to apply to the read-only replica after it is created. Tag names can either be existing or new tags.
        """
        pulumi.set(__self__, "name", name)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_connection is not None:
            pulumi.set(__self__, "private_connection", private_connection)
        if private_network_uuid is not None:
            pulumi.set(__self__, "private_network_uuid", private_network_uuid)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name to give the read-only replicating
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatabaseReplicaConnection']:
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        A time value given in ISO8601 combined date and time format that represents when the database cluster was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference a database replica.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="privateConnection")
    def private_connection(self) -> Optional['outputs.DatabaseReplicaPrivateConnection']:
        return pulumi.get(self, "private_connection")

    @_builtins.property
    @pulumi.getter(name="privateNetworkUuid")
    def private_network_uuid(self) -> Optional[_builtins.str]:
        """
        A string specifying the UUID of the VPC to which the read-only replica will be assigned. If excluded, the replica will be assigned to your account's default VPC for the region.
        """
        return pulumi.get(self, "private_network_uuid")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        A slug identifier for the region where the read-only replica will be located. If excluded, the replica will be placed in the same region as the cluster.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        A slug identifier representing the size of the node for the read-only replica. The size of the replica must be at least as large as the node size for the database cluster from which it is replicating.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['DatabaseReplicaStatus']:
        """
        A string representing the current status of the database cluster.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        A flat array of tag names as strings to apply to the read-only replica after it is created. Tag names can either be existing or new tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DatabaseReplicaConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatabaseReplicaPrivateConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatabaseUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 mysql_settings: Optional['outputs.MysqlSettings'] = None,
                 password: Optional[_builtins.str] = None,
                 role: Optional['DatabaseUserRole'] = None):
        """
        :param _builtins.str name: The name of a database user.
        :param _builtins.str password: A randomly generated password for the database user.
        :param 'DatabaseUserRole' role: A string representing the database user's role. The value will be either
               "primary" or "normal".
        """
        pulumi.set(__self__, "name", name)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of a database user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional['outputs.MysqlSettings']:
        return pulumi.get(self, "mysql_settings")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        A randomly generated password for the database user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional['DatabaseUserRole']:
        """
        A string representing the database user's role. The value will be either
        "primary" or "normal".
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class DatabaseVersionAvailability(dict):
    def __init__(__self__, *,
                 end_of_availability: Optional[_builtins.str] = None,
                 end_of_life: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_of_availability: A timestamp referring to the date when the particular version will no longer be available for creating new clusters. If null, the version does not have an end of availability timeline.
        :param _builtins.str end_of_life: A timestamp referring to the date when the particular version will no longer be supported. If null, the version does not have an end of life timeline.
        :param _builtins.str version: The engine version.
        """
        if end_of_availability is not None:
            pulumi.set(__self__, "end_of_availability", end_of_availability)
        if end_of_life is not None:
            pulumi.set(__self__, "end_of_life", end_of_life)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="endOfAvailability")
    def end_of_availability(self) -> Optional[_builtins.str]:
        """
        A timestamp referring to the date when the particular version will no longer be available for creating new clusters. If null, the version does not have an end of availability timeline.
        """
        return pulumi.get(self, "end_of_availability")

    @_builtins.property
    @pulumi.getter(name="endOfLife")
    def end_of_life(self) -> Optional[_builtins.str]:
        """
        A timestamp referring to the date when the particular version will no longer be supported. If null, the version does not have an end of life timeline.
        """
        return pulumi.get(self, "end_of_life")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The engine version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class FirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterUuid":
            suggest = "cluster_uuid"
        elif key == "createdAt":
            suggest = "created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'FirewallRuleType',
                 value: _builtins.str,
                 cluster_uuid: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param 'FirewallRuleType' type: The type of resource that the firewall rule allows to access the database cluster.
        :param _builtins.str value: The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        :param _builtins.str cluster_uuid: A unique ID for the database cluster to which the rule is applied.
        :param _builtins.str created_at: A time value given in ISO8601 combined date and time format that represents when the firewall rule was created.
        :param _builtins.str uuid: A unique ID for the firewall rule itself.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if cluster_uuid is not None:
            pulumi.set(__self__, "cluster_uuid", cluster_uuid)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FirewallRuleType':
        """
        The type of resource that the firewall rule allows to access the database cluster.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="clusterUuid")
    def cluster_uuid(self) -> Optional[_builtins.str]:
        """
        A unique ID for the database cluster to which the rule is applied.
        """
        return pulumi.get(self, "cluster_uuid")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        A time value given in ISO8601 combined date and time format that represents when the firewall rule was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        A unique ID for the firewall rule itself.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class Mysql(dict):
    def __init__(__self__, *,
                 backup_hour: Optional[_builtins.int] = None,
                 backup_minute: Optional[_builtins.int] = None,
                 binlog_retention_period: Optional[_builtins.float] = None,
                 connect_timeout: Optional[_builtins.int] = None,
                 default_time_zone: Optional[_builtins.str] = None,
                 group_concat_max_len: Optional[_builtins.int] = None,
                 information_schema_stats_expiry: Optional[_builtins.int] = None,
                 innodb_ft_min_token_size: Optional[_builtins.int] = None,
                 innodb_ft_server_stopword_table: Optional[_builtins.str] = None,
                 innodb_lock_wait_timeout: Optional[_builtins.int] = None,
                 innodb_log_buffer_size: Optional[_builtins.int] = None,
                 innodb_online_alter_log_max_size: Optional[_builtins.int] = None,
                 innodb_print_all_deadlocks: Optional[_builtins.bool] = None,
                 innodb_rollback_on_timeout: Optional[_builtins.bool] = None,
                 interactive_timeout: Optional[_builtins.int] = None,
                 internal_tmp_mem_storage_engine: Optional['MysqlInternalTmpMemStorageEngine'] = None,
                 long_query_time: Optional[_builtins.float] = None,
                 max_allowed_packet: Optional[_builtins.int] = None,
                 max_heap_table_size: Optional[_builtins.int] = None,
                 net_read_timeout: Optional[_builtins.int] = None,
                 net_write_timeout: Optional[_builtins.int] = None,
                 slow_query_log: Optional[_builtins.bool] = None,
                 sort_buffer_size: Optional[_builtins.int] = None,
                 sql_mode: Optional[_builtins.str] = None,
                 sql_require_primary_key: Optional[_builtins.bool] = None,
                 tmp_table_size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 wait_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int backup_hour: The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
        :param _builtins.int backup_minute: The minute of the backup hour when backup for the service starts. New backup  only starts if previous backup has already completed.
        :param _builtins.float binlog_retention_period: The minimum amount of time, in seconds, to keep binlog entries before deletion.  This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
        :param _builtins.int connect_timeout: The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
        :param _builtins.str default_time_zone: Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or 'SYSTEM' to use the MySQL server default.
        :param _builtins.int group_concat_max_len: The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
        :param _builtins.int information_schema_stats_expiry: The time, in seconds, before cached statistics expire.
        :param _builtins.int innodb_ft_min_token_size: The minimum length of words that an InnoDB FULLTEXT index stores.
        :param _builtins.str innodb_ft_server_stopword_table: The InnoDB FULLTEXT index stopword list for all InnoDB tables.
        :param _builtins.int innodb_lock_wait_timeout: The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
        :param _builtins.int innodb_log_buffer_size: The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
        :param _builtins.int innodb_online_alter_log_max_size: The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
        :param _builtins.bool innodb_print_all_deadlocks: When enabled, records information about all deadlocks in InnoDB user transactions  in the error log. Disabled by default.
        :param _builtins.bool innodb_rollback_on_timeout: When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
        :param _builtins.int interactive_timeout: The time, in seconds, the server waits for activity on an interactive. connection before closing it.
        :param 'MysqlInternalTmpMemStorageEngine' internal_tmp_mem_storage_engine: The storage engine for in-memory internal temporary tables.
        :param _builtins.float long_query_time: The time, in seconds, for a query to take to execute before  being captured by slow_query_logs. Default is 10 seconds.
        :param _builtins.int max_allowed_packet: The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
        :param _builtins.int max_heap_table_size: The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
        :param _builtins.int net_read_timeout: The time, in seconds, to wait for more data from an existing connection. aborting the read.
        :param _builtins.int net_write_timeout: The number of seconds to wait for a block to be written to a connection before aborting the write.
        :param _builtins.bool slow_query_log: When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
        :param _builtins.int sort_buffer_size: The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
        :param _builtins.str sql_mode: Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
        :param _builtins.bool sql_require_primary_key: Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        :param _builtins.int tmp_table_size: The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        :param _builtins.int wait_timeout: The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if type is None:
            type = 'mysql'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @_builtins.property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[_builtins.int]:
        """
        The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @_builtins.property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[_builtins.int]:
        """
        The minute of the backup hour when backup for the service starts. New backup  only starts if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @_builtins.property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[_builtins.float]:
        """
        The minimum amount of time, in seconds, to keep binlog entries before deletion.  This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
        """
        return pulumi.get(self, "binlog_retention_period")

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[_builtins.int]:
        """
        The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[_builtins.str]:
        """
        Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or 'SYSTEM' to use the MySQL server default.
        """
        return pulumi.get(self, "default_time_zone")

    @_builtins.property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[_builtins.int]:
        """
        The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
        """
        return pulumi.get(self, "group_concat_max_len")

    @_builtins.property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[_builtins.int]:
        """
        The time, in seconds, before cached statistics expire.
        """
        return pulumi.get(self, "information_schema_stats_expiry")

    @_builtins.property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[_builtins.int]:
        """
        The minimum length of words that an InnoDB FULLTEXT index stores.
        """
        return pulumi.get(self, "innodb_ft_min_token_size")

    @_builtins.property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[_builtins.str]:
        """
        The InnoDB FULLTEXT index stopword list for all InnoDB tables.
        """
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @_builtins.property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[_builtins.int]:
        """
        The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
        """
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @_builtins.property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[_builtins.int]:
        """
        The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
        """
        return pulumi.get(self, "innodb_log_buffer_size")

    @_builtins.property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[_builtins.int]:
        """
        The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
        """
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @_builtins.property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[_builtins.bool]:
        """
        When enabled, records information about all deadlocks in InnoDB user transactions  in the error log. Disabled by default.
        """
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @_builtins.property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[_builtins.bool]:
        """
        When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
        """
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @_builtins.property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[_builtins.int]:
        """
        The time, in seconds, the server waits for activity on an interactive. connection before closing it.
        """
        return pulumi.get(self, "interactive_timeout")

    @_builtins.property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional['MysqlInternalTmpMemStorageEngine']:
        """
        The storage engine for in-memory internal temporary tables.
        """
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @_builtins.property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[_builtins.float]:
        """
        The time, in seconds, for a query to take to execute before  being captured by slow_query_logs. Default is 10 seconds.
        """
        return pulumi.get(self, "long_query_time")

    @_builtins.property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[_builtins.int]:
        """
        The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
        """
        return pulumi.get(self, "max_allowed_packet")

    @_builtins.property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[_builtins.int]:
        """
        The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
        """
        return pulumi.get(self, "max_heap_table_size")

    @_builtins.property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[_builtins.int]:
        """
        The time, in seconds, to wait for more data from an existing connection. aborting the read.
        """
        return pulumi.get(self, "net_read_timeout")

    @_builtins.property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait for a block to be written to a connection before aborting the write.
        """
        return pulumi.get(self, "net_write_timeout")

    @_builtins.property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[_builtins.bool]:
        """
        When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
        """
        return pulumi.get(self, "slow_query_log")

    @_builtins.property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[_builtins.int]:
        """
        The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
        """
        return pulumi.get(self, "sort_buffer_size")

    @_builtins.property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[_builtins.str]:
        """
        Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
        """
        return pulumi.get(self, "sql_mode")

    @_builtins.property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[_builtins.bool]:
        """
        Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        """
        return pulumi.get(self, "sql_require_primary_key")

    @_builtins.property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[_builtins.int]:
        """
        The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "tmp_table_size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[_builtins.int]:
        """
        The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        return pulumi.get(self, "wait_timeout")


@pulumi.output_type
class MysqlSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authPlugin":
            suggest = "auth_plugin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MysqlSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MysqlSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MysqlSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_plugin: 'MysqlSettingsAuthPlugin'):
        """
        :param 'MysqlSettingsAuthPlugin' auth_plugin: A string specifying the authentication method to be used for connections
               to the MySQL user account. The valid values are `mysql_native_password`
               or `caching_sha2_password`. If excluded when creating a new user, the
               default for the version of MySQL in use will be used. As of MySQL 8.0, the
               default is `caching_sha2_password`.
        """
        pulumi.set(__self__, "auth_plugin", auth_plugin)

    @_builtins.property
    @pulumi.getter(name="authPlugin")
    def auth_plugin(self) -> 'MysqlSettingsAuthPlugin':
        """
        A string specifying the authentication method to be used for connections
        to the MySQL user account. The valid values are `mysql_native_password`
        or `caching_sha2_password`. If excluded when creating a new user, the
        default for the version of MySQL in use will be used. As of MySQL 8.0, the
        default is `caching_sha2_password`.
        """
        return pulumi.get(self, "auth_plugin")


@pulumi.output_type
class OptionsOptionsProperties(dict):
    def __init__(__self__, *,
                 mongodb: Optional['outputs.OptionsOptionsPropertiesMongodb'] = None,
                 mysql: Optional['outputs.OptionsOptionsPropertiesMysql'] = None,
                 pg: Optional['outputs.OptionsOptionsPropertiesPg'] = None,
                 redis: Optional['outputs.OptionsOptionsPropertiesRedis'] = None):
        if mongodb is not None:
            pulumi.set(__self__, "mongodb", mongodb)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @_builtins.property
    @pulumi.getter
    def mongodb(self) -> Optional['outputs.OptionsOptionsPropertiesMongodb']:
        return pulumi.get(self, "mongodb")

    @_builtins.property
    @pulumi.getter
    def mysql(self) -> Optional['outputs.OptionsOptionsPropertiesMysql']:
        return pulumi.get(self, "mysql")

    @_builtins.property
    @pulumi.getter
    def pg(self) -> Optional['outputs.OptionsOptionsPropertiesPg']:
        return pulumi.get(self, "pg")

    @_builtins.property
    @pulumi.getter
    def redis(self) -> Optional['outputs.OptionsOptionsPropertiesRedis']:
        return pulumi.get(self, "redis")


@pulumi.output_type
class OptionsOptionsPropertiesMongodb(dict):
    def __init__(__self__, *,
                 layouts: Optional[Sequence['outputs.DatabaseLayoutOption']] = None,
                 regions: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['DatabaseLayoutOption'] layouts: An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        :param Sequence[_builtins.str] regions: An array of strings containing the names of available regions
        :param Sequence[_builtins.str] versions: An array of strings containing the names of available regions
        """
        if layouts is not None:
            pulumi.set(__self__, "layouts", layouts)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.DatabaseLayoutOption']]:
        """
        An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        """
        return pulumi.get(self, "layouts")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class OptionsOptionsPropertiesMysql(dict):
    def __init__(__self__, *,
                 layouts: Optional[Sequence['outputs.DatabaseLayoutOption']] = None,
                 regions: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['DatabaseLayoutOption'] layouts: An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        :param Sequence[_builtins.str] regions: An array of strings containing the names of available regions
        :param Sequence[_builtins.str] versions: An array of strings containing the names of available regions
        """
        if layouts is not None:
            pulumi.set(__self__, "layouts", layouts)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.DatabaseLayoutOption']]:
        """
        An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        """
        return pulumi.get(self, "layouts")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class OptionsOptionsPropertiesPg(dict):
    def __init__(__self__, *,
                 layouts: Optional[Sequence['outputs.DatabaseLayoutOption']] = None,
                 regions: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['DatabaseLayoutOption'] layouts: An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        :param Sequence[_builtins.str] regions: An array of strings containing the names of available regions
        :param Sequence[_builtins.str] versions: An array of strings containing the names of available regions
        """
        if layouts is not None:
            pulumi.set(__self__, "layouts", layouts)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.DatabaseLayoutOption']]:
        """
        An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        """
        return pulumi.get(self, "layouts")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class OptionsOptionsPropertiesRedis(dict):
    def __init__(__self__, *,
                 layouts: Optional[Sequence['outputs.DatabaseLayoutOption']] = None,
                 regions: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['DatabaseLayoutOption'] layouts: An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        :param Sequence[_builtins.str] regions: An array of strings containing the names of available regions
        :param Sequence[_builtins.str] versions: An array of strings containing the names of available regions
        """
        if layouts is not None:
            pulumi.set(__self__, "layouts", layouts)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.DatabaseLayoutOption']]:
        """
        An array of objects, each indicating the node sizes (otherwise referred to as slugs) that are available with various numbers of nodes in the database cluster. Each slugs denotes the node's identifier, CPU, and RAM (in that order).
        """
        return pulumi.get(self, "layouts")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the names of available regions
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class OptionsVersionAvailabilityProperties(dict):
    def __init__(__self__, *,
                 mongodb: Optional[Sequence['outputs.DatabaseVersionAvailability']] = None,
                 mysql: Optional[Sequence['outputs.DatabaseVersionAvailability']] = None,
                 pg: Optional[Sequence['outputs.DatabaseVersionAvailability']] = None,
                 redis: Optional[Sequence['outputs.DatabaseVersionAvailability']] = None):
        """
        :param Sequence['DatabaseVersionAvailability'] mongodb: An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        :param Sequence['DatabaseVersionAvailability'] mysql: An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        :param Sequence['DatabaseVersionAvailability'] pg: An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        :param Sequence['DatabaseVersionAvailability'] redis: An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        """
        if mongodb is not None:
            pulumi.set(__self__, "mongodb", mongodb)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @_builtins.property
    @pulumi.getter
    def mongodb(self) -> Optional[Sequence['outputs.DatabaseVersionAvailability']]:
        """
        An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        """
        return pulumi.get(self, "mongodb")

    @_builtins.property
    @pulumi.getter
    def mysql(self) -> Optional[Sequence['outputs.DatabaseVersionAvailability']]:
        """
        An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        """
        return pulumi.get(self, "mysql")

    @_builtins.property
    @pulumi.getter
    def pg(self) -> Optional[Sequence['outputs.DatabaseVersionAvailability']]:
        """
        An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        """
        return pulumi.get(self, "pg")

    @_builtins.property
    @pulumi.getter
    def redis(self) -> Optional[Sequence['outputs.DatabaseVersionAvailability']]:
        """
        An array of objects, each indicating the version end-of-life, end-of-availability for various database engines
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class Pgbouncer(dict):
    """
    PGBouncer connection pooling settings
    """
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[_builtins.int] = None,
                 autodb_max_db_connections: Optional[_builtins.int] = None,
                 autodb_pool_mode: Optional['PgbouncerAutodbPoolMode'] = None,
                 autodb_pool_size: Optional[_builtins.int] = None,
                 ignore_startup_parameters: Optional[Sequence['PgbouncerIgnoreStartupParametersItem']] = None,
                 min_pool_size: Optional[_builtins.int] = None,
                 server_idle_timeout: Optional[_builtins.int] = None,
                 server_lifetime: Optional[_builtins.int] = None,
                 server_reset_query_always: Optional[_builtins.bool] = None):
        """
        PGBouncer connection pooling settings
        :param _builtins.int autodb_idle_timeout: If the automatically-created database pools have been unused this many seconds, they are freed. If 0, timeout is disabled.
        :param _builtins.int autodb_max_db_connections: Only allows a maximum this many server connections per database (regardless of user). If 0, allows unlimited connections.
        :param 'PgbouncerAutodbPoolMode' autodb_pool_mode: PGBouncer pool mode
        :param _builtins.int autodb_pool_size: If non-zero, automatically creates a pool of that size per user when a pool doesn't exist.
        :param Sequence['PgbouncerIgnoreStartupParametersItem'] ignore_startup_parameters: List of parameters to ignore when given in startup packet.
        :param _builtins.int min_pool_size: If current server connections are below this number, adds more. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        :param _builtins.int server_idle_timeout: Drops server connections if they have been idle more than this many seconds.  If 0, timeout is disabled. 
        :param _builtins.int server_lifetime: The pooler closes any unused server connection that has been connected longer than this amount of seconds.
        :param _builtins.bool server_reset_query_always: Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @_builtins.property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[_builtins.int]:
        """
        If the automatically-created database pools have been unused this many seconds, they are freed. If 0, timeout is disabled.
        """
        return pulumi.get(self, "autodb_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[_builtins.int]:
        """
        Only allows a maximum this many server connections per database (regardless of user). If 0, allows unlimited connections.
        """
        return pulumi.get(self, "autodb_max_db_connections")

    @_builtins.property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional['PgbouncerAutodbPoolMode']:
        """
        PGBouncer pool mode
        """
        return pulumi.get(self, "autodb_pool_mode")

    @_builtins.property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[_builtins.int]:
        """
        If non-zero, automatically creates a pool of that size per user when a pool doesn't exist.
        """
        return pulumi.get(self, "autodb_pool_size")

    @_builtins.property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence['PgbouncerIgnoreStartupParametersItem']]:
        """
        List of parameters to ignore when given in startup packet.
        """
        return pulumi.get(self, "ignore_startup_parameters")

    @_builtins.property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[_builtins.int]:
        """
        If current server connections are below this number, adds more. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        """
        return pulumi.get(self, "min_pool_size")

    @_builtins.property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[_builtins.int]:
        """
        Drops server connections if they have been idle more than this many seconds.  If 0, timeout is disabled. 
        """
        return pulumi.get(self, "server_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[_builtins.int]:
        """
        The pooler closes any unused server connection that has been connected longer than this amount of seconds.
        """
        return pulumi.get(self, "server_lifetime")

    @_builtins.property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[_builtins.bool]:
        """
        Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class Postgres(dict):
    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[_builtins.float] = None,
                 autovacuum_analyze_threshold: Optional[_builtins.int] = None,
                 autovacuum_freeze_max_age: Optional[_builtins.int] = None,
                 autovacuum_max_workers: Optional[_builtins.int] = None,
                 autovacuum_naptime: Optional[_builtins.int] = None,
                 autovacuum_vacuum_cost_delay: Optional[_builtins.int] = None,
                 autovacuum_vacuum_cost_limit: Optional[_builtins.int] = None,
                 autovacuum_vacuum_scale_factor: Optional[_builtins.float] = None,
                 autovacuum_vacuum_threshold: Optional[_builtins.int] = None,
                 backup_hour: Optional[_builtins.int] = None,
                 backup_minute: Optional[_builtins.int] = None,
                 bgwriter_delay: Optional[_builtins.int] = None,
                 bgwriter_flush_after: Optional[_builtins.int] = None,
                 bgwriter_lru_maxpages: Optional[_builtins.int] = None,
                 bgwriter_lru_multiplier: Optional[_builtins.float] = None,
                 deadlock_timeout: Optional[_builtins.int] = None,
                 default_toast_compression: Optional['PostgresDefaultToastCompression'] = None,
                 idle_in_transaction_session_timeout: Optional[_builtins.int] = None,
                 jit: Optional[_builtins.bool] = None,
                 log_autovacuum_min_duration: Optional[_builtins.int] = None,
                 log_error_verbosity: Optional['PostgresLogErrorVerbosity'] = None,
                 log_line_prefix: Optional['PostgresLogLinePrefix'] = None,
                 log_min_duration_statement: Optional[_builtins.int] = None,
                 max_files_per_process: Optional[_builtins.int] = None,
                 max_locks_per_transaction: Optional[_builtins.int] = None,
                 max_logical_replication_workers: Optional[_builtins.int] = None,
                 max_parallel_workers: Optional[_builtins.int] = None,
                 max_parallel_workers_per_gather: Optional[_builtins.int] = None,
                 max_pred_locks_per_transaction: Optional[_builtins.int] = None,
                 max_prepared_transactions: Optional[_builtins.int] = None,
                 max_replication_slots: Optional[_builtins.int] = None,
                 max_stack_depth: Optional[_builtins.int] = None,
                 max_standby_archive_delay: Optional[_builtins.int] = None,
                 max_standby_streaming_delay: Optional[_builtins.int] = None,
                 max_wal_senders: Optional[_builtins.int] = None,
                 max_worker_processes: Optional[_builtins.int] = None,
                 pg_partman_bgw_interval: Optional[_builtins.int] = None,
                 pg_partman_bgw_role: Optional[_builtins.str] = None,
                 pg_stat_statements_track: Optional['PostgresPgStatStatementsTrack'] = None,
                 pgbouncer: Optional['outputs.Pgbouncer'] = None,
                 shared_buffers_percentage: Optional[_builtins.float] = None,
                 stat_monitor_enable: Optional[_builtins.bool] = None,
                 synchronous_replication: Optional['PostgresSynchronousReplication'] = None,
                 temp_file_limit: Optional[_builtins.int] = None,
                 timescaledb: Optional['outputs.Timescaledb'] = None,
                 timezone: Optional[_builtins.str] = None,
                 track_activity_query_size: Optional[_builtins.int] = None,
                 track_commit_timestamp: Optional['PostgresTrackCommitTimestamp'] = None,
                 track_functions: Optional['PostgresTrackFunctions'] = None,
                 track_io_timing: Optional['PostgresTrackIoTiming'] = None,
                 type: Optional[_builtins.str] = None,
                 wal_sender_timeout: Optional[_builtins.int] = None,
                 wal_writer_delay: Optional[_builtins.int] = None,
                 work_mem: Optional[_builtins.int] = None):
        """
        :param _builtins.float autovacuum_analyze_scale_factor: Specifies a fraction, in a decimal value, of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        :param _builtins.int autovacuum_analyze_threshold: Specifies the minimum number of inserted, updated, or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        :param _builtins.int autovacuum_freeze_max_age: Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        :param _builtins.int autovacuum_max_workers: Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        :param _builtins.int autovacuum_naptime: Specifies the minimum delay, in seconds, between autovacuum runs on any given database. The default is one minute.
        :param _builtins.int autovacuum_vacuum_cost_delay: Specifies the cost delay value, in milliseconds, that will be used in automatic VACUUM operations. If -1, uses the regular vacuum_cost_delay value, which is 20 milliseconds.
        :param _builtins.int autovacuum_vacuum_cost_limit: Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        :param _builtins.float autovacuum_vacuum_scale_factor: Specifies a fraction, in a decimal value, of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        :param _builtins.int autovacuum_vacuum_threshold: Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        :param _builtins.int backup_hour: The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
        :param _builtins.int backup_minute: The minute of the backup hour when backup for the service starts. New backup is only started if previous backup has already completed.
        :param _builtins.int bgwriter_delay: Specifies the delay, in milliseconds, between activity rounds for the background writer. Default is 200 ms.
        :param _builtins.int bgwriter_flush_after: The amount of kilobytes that need to be written by the background writer before attempting to force the OS to issue these writes to underlying storage. Specified in kilobytes, default is 512.  Setting of 0 disables forced writeback.
        :param _builtins.int bgwriter_lru_maxpages: The maximum number of buffers that the background writer can write. Setting this to zero disables background writing. Default is 100.
        :param _builtins.float bgwriter_lru_multiplier: The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        :param _builtins.int deadlock_timeout: The amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        :param 'PostgresDefaultToastCompression' default_toast_compression: Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        :param _builtins.int idle_in_transaction_session_timeout: Time out sessions with open transactions after this number of milliseconds
        :param _builtins.bool jit: Activates, in a boolean, the system-wide use of Just-in-Time Compilation (JIT).
        :param _builtins.int log_autovacuum_min_duration: Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        :param 'PostgresLogErrorVerbosity' log_error_verbosity: Controls the amount of detail written in the server log for each message that is logged.
        :param 'PostgresLogLinePrefix' log_line_prefix: Selects one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze, etc.
        :param _builtins.int log_min_duration_statement: Log statements that take more than this number of milliseconds to run. If -1, disables.
        :param _builtins.int max_files_per_process: PostgreSQL maximum number of files that can be open per process.
        :param _builtins.int max_locks_per_transaction: PostgreSQL maximum locks per transaction. Once increased, this parameter cannot be lowered from its set value.
        :param _builtins.int max_logical_replication_workers: PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        :param _builtins.int max_parallel_workers: Sets the maximum number of workers that the system can support for parallel queries.
        :param _builtins.int max_parallel_workers_per_gather: Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        :param _builtins.int max_pred_locks_per_transaction: PostgreSQL maximum predicate locks per transaction.
        :param _builtins.int max_prepared_transactions: PostgreSQL maximum prepared transactions. Once increased, this parameter cannot be lowered from its set value.
        :param _builtins.int max_replication_slots: PostgreSQL maximum replication slots.
        :param _builtins.int max_stack_depth: Maximum depth of the stack in bytes.
        :param _builtins.int max_standby_archive_delay: Max standby archive delay in milliseconds.
        :param _builtins.int max_standby_streaming_delay: Max standby streaming delay in milliseconds.
        :param _builtins.int max_wal_senders: PostgreSQL maximum WAL senders. Once increased, this parameter cannot be lowered from its set value.
        :param _builtins.int max_worker_processes: Sets the maximum number of background processes that the system can support. Once increased, this parameter cannot be lowered from its set value.
        :param _builtins.int pg_partman_bgw_interval: Sets the time interval to run pg_partman's scheduled tasks.
        :param _builtins.str pg_partman_bgw_role: Controls which role to use for pg_partman's scheduled background tasks. Must consist of alpha-numeric characters, dots, underscores, or dashes. May not start with dash or dot. Maximum of 64 characters.
        :param 'PostgresPgStatStatementsTrack' pg_stat_statements_track: Controls which statements are counted. Specify 'top' to track top-level statements (those issued directly by clients), 'all' to also track nested statements (such as statements invoked within functions), or 'none' to disable statement statistics collection. The default value is top.
        :param 'Pgbouncer' pgbouncer: PGBouncer connection pooling settings
        :param _builtins.float shared_buffers_percentage: Percentage of total RAM that the database server uses for shared memory buffers.  Valid range is 20-60 (float), which corresponds to 20% - 60%.  This setting adjusts the shared_buffers configuration value.
        :param _builtins.bool stat_monitor_enable: Enable the pg_stat_monitor extension. <b>Enabling this extension will cause the cluster to be restarted.</b> When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        :param 'PostgresSynchronousReplication' synchronous_replication: Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        :param _builtins.int temp_file_limit: PostgreSQL temporary file limit in KiB. If -1, sets to unlimited.
        :param 'Timescaledb' timescaledb: TimescaleDB extension configuration values
        :param _builtins.str timezone: PostgreSQL service timezone
        :param _builtins.int track_activity_query_size: Specifies the number of bytes reserved to track the currently executing command for each active session.
        :param 'PostgresTrackCommitTimestamp' track_commit_timestamp: Record commit time of transactions.
        :param 'PostgresTrackFunctions' track_functions: Enables tracking of function call counts and time used.
        :param 'PostgresTrackIoTiming' track_io_timing: Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        :param _builtins.int wal_sender_timeout: Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout. Must be either 0 or between 5000 and 10800000.
        :param _builtins.int wal_writer_delay: WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance
        :param _builtins.int work_mem: The maximum amount of memory, in MB, used by a query operation (such as a sort or hash table) before writing to temporary disk files. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if pg_partman_bgw_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_interval", pg_partman_bgw_interval)
        if pg_partman_bgw_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_role", pg_partman_bgw_role)
        if pg_stat_statements_track is not None:
            pulumi.set(__self__, "pg_stat_statements_track", pg_stat_statements_track)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if stat_monitor_enable is not None:
            pulumi.set(__self__, "stat_monitor_enable", stat_monitor_enable)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if type is None:
            type = 'postgres'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @_builtins.property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[_builtins.float]:
        """
        Specifies a fraction, in a decimal value, of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @_builtins.property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum number of inserted, updated, or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @_builtins.property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        """
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @_builtins.property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        """
        return pulumi.get(self, "autovacuum_max_workers")

    @_builtins.property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum delay, in seconds, between autovacuum runs on any given database. The default is one minute.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @_builtins.property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[_builtins.int]:
        """
        Specifies the cost delay value, in milliseconds, that will be used in automatic VACUUM operations. If -1, uses the regular vacuum_cost_delay value, which is 20 milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @_builtins.property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[_builtins.int]:
        """
        Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @_builtins.property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[_builtins.float]:
        """
        Specifies a fraction, in a decimal value, of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @_builtins.property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @_builtins.property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[_builtins.int]:
        """
        The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @_builtins.property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[_builtins.int]:
        """
        The minute of the backup hour when backup for the service starts. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @_builtins.property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[_builtins.int]:
        """
        Specifies the delay, in milliseconds, between activity rounds for the background writer. Default is 200 ms.
        """
        return pulumi.get(self, "bgwriter_delay")

    @_builtins.property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[_builtins.int]:
        """
        The amount of kilobytes that need to be written by the background writer before attempting to force the OS to issue these writes to underlying storage. Specified in kilobytes, default is 512.  Setting of 0 disables forced writeback.
        """
        return pulumi.get(self, "bgwriter_flush_after")

    @_builtins.property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[_builtins.int]:
        """
        The maximum number of buffers that the background writer can write. Setting this to zero disables background writing. Default is 100.
        """
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @_builtins.property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[_builtins.float]:
        """
        The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        """
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @_builtins.property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[_builtins.int]:
        """
        The amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        """
        return pulumi.get(self, "deadlock_timeout")

    @_builtins.property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional['PostgresDefaultToastCompression']:
        """
        Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        """
        return pulumi.get(self, "default_toast_compression")

    @_builtins.property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[_builtins.int]:
        """
        Time out sessions with open transactions after this number of milliseconds
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @_builtins.property
    @pulumi.getter
    def jit(self) -> Optional[_builtins.bool]:
        """
        Activates, in a boolean, the system-wide use of Just-in-Time Compilation (JIT).
        """
        return pulumi.get(self, "jit")

    @_builtins.property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[_builtins.int]:
        """
        Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        """
        return pulumi.get(self, "log_autovacuum_min_duration")

    @_builtins.property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional['PostgresLogErrorVerbosity']:
        """
        Controls the amount of detail written in the server log for each message that is logged.
        """
        return pulumi.get(self, "log_error_verbosity")

    @_builtins.property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional['PostgresLogLinePrefix']:
        """
        Selects one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze, etc.
        """
        return pulumi.get(self, "log_line_prefix")

    @_builtins.property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[_builtins.int]:
        """
        Log statements that take more than this number of milliseconds to run. If -1, disables.
        """
        return pulumi.get(self, "log_min_duration_statement")

    @_builtins.property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum number of files that can be open per process.
        """
        return pulumi.get(self, "max_files_per_process")

    @_builtins.property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum locks per transaction. Once increased, this parameter cannot be lowered from its set value.
        """
        return pulumi.get(self, "max_locks_per_transaction")

    @_builtins.property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        """
        return pulumi.get(self, "max_logical_replication_workers")

    @_builtins.property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[_builtins.int]:
        """
        Sets the maximum number of workers that the system can support for parallel queries.
        """
        return pulumi.get(self, "max_parallel_workers")

    @_builtins.property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[_builtins.int]:
        """
        Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        """
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @_builtins.property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum predicate locks per transaction.
        """
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @_builtins.property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum prepared transactions. Once increased, this parameter cannot be lowered from its set value.
        """
        return pulumi.get(self, "max_prepared_transactions")

    @_builtins.property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum replication slots.
        """
        return pulumi.get(self, "max_replication_slots")

    @_builtins.property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[_builtins.int]:
        """
        Maximum depth of the stack in bytes.
        """
        return pulumi.get(self, "max_stack_depth")

    @_builtins.property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[_builtins.int]:
        """
        Max standby archive delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_archive_delay")

    @_builtins.property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[_builtins.int]:
        """
        Max standby streaming delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_streaming_delay")

    @_builtins.property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[_builtins.int]:
        """
        PostgreSQL maximum WAL senders. Once increased, this parameter cannot be lowered from its set value.
        """
        return pulumi.get(self, "max_wal_senders")

    @_builtins.property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[_builtins.int]:
        """
        Sets the maximum number of background processes that the system can support. Once increased, this parameter cannot be lowered from its set value.
        """
        return pulumi.get(self, "max_worker_processes")

    @_builtins.property
    @pulumi.getter(name="pgPartmanBgwInterval")
    def pg_partman_bgw_interval(self) -> Optional[_builtins.int]:
        """
        Sets the time interval to run pg_partman's scheduled tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_interval")

    @_builtins.property
    @pulumi.getter(name="pgPartmanBgwRole")
    def pg_partman_bgw_role(self) -> Optional[_builtins.str]:
        """
        Controls which role to use for pg_partman's scheduled background tasks. Must consist of alpha-numeric characters, dots, underscores, or dashes. May not start with dash or dot. Maximum of 64 characters.
        """
        return pulumi.get(self, "pg_partman_bgw_role")

    @_builtins.property
    @pulumi.getter(name="pgStatStatementsTrack")
    def pg_stat_statements_track(self) -> Optional['PostgresPgStatStatementsTrack']:
        """
        Controls which statements are counted. Specify 'top' to track top-level statements (those issued directly by clients), 'all' to also track nested statements (such as statements invoked within functions), or 'none' to disable statement statistics collection. The default value is top.
        """
        return pulumi.get(self, "pg_stat_statements_track")

    @_builtins.property
    @pulumi.getter
    def pgbouncer(self) -> Optional['outputs.Pgbouncer']:
        """
        PGBouncer connection pooling settings
        """
        return pulumi.get(self, "pgbouncer")

    @_builtins.property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[_builtins.float]:
        """
        Percentage of total RAM that the database server uses for shared memory buffers.  Valid range is 20-60 (float), which corresponds to 20% - 60%.  This setting adjusts the shared_buffers configuration value.
        """
        return pulumi.get(self, "shared_buffers_percentage")

    @_builtins.property
    @pulumi.getter(name="statMonitorEnable")
    def stat_monitor_enable(self) -> Optional[_builtins.bool]:
        """
        Enable the pg_stat_monitor extension. <b>Enabling this extension will cause the cluster to be restarted.</b> When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        """
        return pulumi.get(self, "stat_monitor_enable")

    @_builtins.property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional['PostgresSynchronousReplication']:
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        return pulumi.get(self, "synchronous_replication")

    @_builtins.property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[_builtins.int]:
        """
        PostgreSQL temporary file limit in KiB. If -1, sets to unlimited.
        """
        return pulumi.get(self, "temp_file_limit")

    @_builtins.property
    @pulumi.getter
    def timescaledb(self) -> Optional['outputs.Timescaledb']:
        """
        TimescaleDB extension configuration values
        """
        return pulumi.get(self, "timescaledb")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        PostgreSQL service timezone
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[_builtins.int]:
        """
        Specifies the number of bytes reserved to track the currently executing command for each active session.
        """
        return pulumi.get(self, "track_activity_query_size")

    @_builtins.property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional['PostgresTrackCommitTimestamp']:
        """
        Record commit time of transactions.
        """
        return pulumi.get(self, "track_commit_timestamp")

    @_builtins.property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional['PostgresTrackFunctions']:
        """
        Enables tracking of function call counts and time used.
        """
        return pulumi.get(self, "track_functions")

    @_builtins.property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional['PostgresTrackIoTiming']:
        """
        Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        """
        return pulumi.get(self, "track_io_timing")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[_builtins.int]:
        """
        Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout. Must be either 0 or between 5000 and 10800000.
        """
        return pulumi.get(self, "wal_sender_timeout")

    @_builtins.property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[_builtins.int]:
        """
        WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance
        """
        return pulumi.get(self, "wal_writer_delay")

    @_builtins.property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[_builtins.int]:
        """
        The maximum amount of memory, in MB, used by a query operation (such as a sort or hash table) before writing to temporary disk files. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        return pulumi.get(self, "work_mem")


@pulumi.output_type
class PrivateConnection(dict):
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 ssl: Optional[_builtins.bool] = None,
                 uri: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.bool ssl: A boolean value indicating if the connection should be made over SSL.
        :param _builtins.str uri: A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        :param _builtins.str user: The default user for the database.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating if the connection should be made over SSL.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        A connection string in the format accepted by the `psql` command. This is provided as a convenience and should be able to be constructed by the other attributes.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class Redis(dict):
    def __init__(__self__, *,
                 redis_acl_channels_default: Optional['RedisRedisAclChannelsDefault'] = None,
                 redis_io_threads: Optional[_builtins.int] = None,
                 redis_lfu_decay_time: Optional[_builtins.int] = None,
                 redis_lfu_log_factor: Optional[_builtins.int] = None,
                 redis_maxmemory_policy: Optional['RedisRedisMaxmemoryPolicy'] = None,
                 redis_notify_keyspace_events: Optional[_builtins.str] = None,
                 redis_number_of_databases: Optional[_builtins.int] = None,
                 redis_persistence: Optional['RedisRedisPersistence'] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[_builtins.int] = None,
                 redis_ssl: Optional[_builtins.bool] = None,
                 redis_timeout: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'RedisRedisAclChannelsDefault' redis_acl_channels_default: Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        :param _builtins.int redis_io_threads: Redis IO thread count
        :param _builtins.int redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes
        :param _builtins.int redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
        :param 'RedisRedisMaxmemoryPolicy' redis_maxmemory_policy: A string specifying the desired eviction policy for the Redis cluster.
               
               - `noeviction`: Don't evict any data, returns error when memory limit is reached.
               - `allkeys_lru:` Evict any key, least recently used (LRU) first.
               - `allkeys_random`: Evict keys in a random order.
               - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
               - `volatile_random`: Evict keys with expiration only in a random order.
               - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
        :param _builtins.str redis_notify_keyspace_events: Set notify-keyspace-events option
        :param _builtins.int redis_number_of_databases: Set number of redis databases. Changing this will cause a restart of redis service.
        :param 'RedisRedisPersistence' redis_persistence: When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
        :param _builtins.int redis_pubsub_client_output_buffer_limit: Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        :param _builtins.bool redis_ssl: Require SSL to access Redis
        :param _builtins.int redis_timeout: Redis idle connection timeout in seconds
        """
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is None:
            redis_lfu_decay_time = 1
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is None:
            redis_lfu_log_factor = 10
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is None:
            redis_notify_keyspace_events = ''
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is None:
            redis_ssl = True
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is None:
            redis_timeout = 300
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if type is None:
            type = 'redis'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional['RedisRedisAclChannelsDefault']:
        """
        Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        """
        return pulumi.get(self, "redis_acl_channels_default")

    @_builtins.property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[_builtins.int]:
        """
        Redis IO thread count
        """
        return pulumi.get(self, "redis_io_threads")

    @_builtins.property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[_builtins.int]:
        """
        LFU maxmemory-policy counter decay time in minutes
        """
        return pulumi.get(self, "redis_lfu_decay_time")

    @_builtins.property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[_builtins.int]:
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
        """
        return pulumi.get(self, "redis_lfu_log_factor")

    @_builtins.property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional['RedisRedisMaxmemoryPolicy']:
        """
        A string specifying the desired eviction policy for the Redis cluster.

        - `noeviction`: Don't evict any data, returns error when memory limit is reached.
        - `allkeys_lru:` Evict any key, least recently used (LRU) first.
        - `allkeys_random`: Evict keys in a random order.
        - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
        - `volatile_random`: Evict keys with expiration only in a random order.
        - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
        """
        return pulumi.get(self, "redis_maxmemory_policy")

    @_builtins.property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[_builtins.str]:
        """
        Set notify-keyspace-events option
        """
        return pulumi.get(self, "redis_notify_keyspace_events")

    @_builtins.property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[_builtins.int]:
        """
        Set number of redis databases. Changing this will cause a restart of redis service.
        """
        return pulumi.get(self, "redis_number_of_databases")

    @_builtins.property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional['RedisRedisPersistence']:
        """
        When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
        """
        return pulumi.get(self, "redis_persistence")

    @_builtins.property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[_builtins.int]:
        """
        Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @_builtins.property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[_builtins.bool]:
        """
        Require SSL to access Redis
        """
        return pulumi.get(self, "redis_ssl")

    @_builtins.property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[_builtins.int]:
        """
        Redis idle connection timeout in seconds
        """
        return pulumi.get(self, "redis_timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SourceProperties(dict):
    def __init__(__self__, *,
                 dbname: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str dbname: The name of the default database.
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: The randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.str username: The default user for the database.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def dbname(self) -> Optional[_builtins.str]:
        """
        The name of the default database.
        """
        return pulumi.get(self, "dbname")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class Timescaledb(dict):
    """
    TimescaleDB extension configuration values
    """
    def __init__(__self__, *,
                 max_background_workers: Optional[_builtins.int] = None):
        """
        TimescaleDB extension configuration values
        :param _builtins.int max_background_workers: The number of background workers for timescaledb operations.  Set to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @_builtins.property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[_builtins.int]:
        """
        The number of background workers for timescaledb operations.  Set to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        return pulumi.get(self, "max_background_workers")


