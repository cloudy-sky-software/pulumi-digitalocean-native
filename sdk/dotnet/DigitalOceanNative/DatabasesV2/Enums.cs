// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace CloudySkySoftware.Pulumi.DigitalOceanNative.DatabasesV2
{
    /// <summary>
    /// A slug representing the database engine used for the cluster. The possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb" for MongoDB.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseClusterEngine : IEquatable<DatabaseClusterEngine>
    {
        private readonly string _value;

        private DatabaseClusterEngine(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseClusterEngine Pg { get; } = new DatabaseClusterEngine("pg");
        public static DatabaseClusterEngine Mysql { get; } = new DatabaseClusterEngine("mysql");
        public static DatabaseClusterEngine Redis { get; } = new DatabaseClusterEngine("redis");
        public static DatabaseClusterEngine Mongodb { get; } = new DatabaseClusterEngine("mongodb");

        public static bool operator ==(DatabaseClusterEngine left, DatabaseClusterEngine right) => left.Equals(right);
        public static bool operator !=(DatabaseClusterEngine left, DatabaseClusterEngine right) => !left.Equals(right);

        public static explicit operator string(DatabaseClusterEngine value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseClusterEngine other && Equals(other);
        public bool Equals(DatabaseClusterEngine other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string representing the current status of the database cluster.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseClusterStatus : IEquatable<DatabaseClusterStatus>
    {
        private readonly string _value;

        private DatabaseClusterStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseClusterStatus Creating { get; } = new DatabaseClusterStatus("creating");
        public static DatabaseClusterStatus Online { get; } = new DatabaseClusterStatus("online");
        public static DatabaseClusterStatus Resizing { get; } = new DatabaseClusterStatus("resizing");
        public static DatabaseClusterStatus Migrating { get; } = new DatabaseClusterStatus("migrating");
        public static DatabaseClusterStatus Forking { get; } = new DatabaseClusterStatus("forking");

        public static bool operator ==(DatabaseClusterStatus left, DatabaseClusterStatus right) => left.Equals(right);
        public static bool operator !=(DatabaseClusterStatus left, DatabaseClusterStatus right) => !left.Equals(right);

        public static explicit operator string(DatabaseClusterStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseClusterStatus other && Equals(other);
        public bool Equals(DatabaseClusterStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string representing the current status of the database cluster.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseReplicaStatus : IEquatable<DatabaseReplicaStatus>
    {
        private readonly string _value;

        private DatabaseReplicaStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseReplicaStatus Creating { get; } = new DatabaseReplicaStatus("creating");
        public static DatabaseReplicaStatus Online { get; } = new DatabaseReplicaStatus("online");
        public static DatabaseReplicaStatus Resizing { get; } = new DatabaseReplicaStatus("resizing");
        public static DatabaseReplicaStatus Migrating { get; } = new DatabaseReplicaStatus("migrating");
        public static DatabaseReplicaStatus Forking { get; } = new DatabaseReplicaStatus("forking");

        public static bool operator ==(DatabaseReplicaStatus left, DatabaseReplicaStatus right) => left.Equals(right);
        public static bool operator !=(DatabaseReplicaStatus left, DatabaseReplicaStatus right) => !left.Equals(right);

        public static explicit operator string(DatabaseReplicaStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseReplicaStatus other && Equals(other);
        public bool Equals(DatabaseReplicaStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string representing the database user's role. The value will be either
    /// "primary" or "normal".
    /// </summary>
    [EnumType]
    public readonly struct DatabaseUserRole : IEquatable<DatabaseUserRole>
    {
        private readonly string _value;

        private DatabaseUserRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseUserRole Primary { get; } = new DatabaseUserRole("primary");
        public static DatabaseUserRole Normal { get; } = new DatabaseUserRole("normal");

        public static bool operator ==(DatabaseUserRole left, DatabaseUserRole right) => left.Equals(right);
        public static bool operator !=(DatabaseUserRole left, DatabaseUserRole right) => !left.Equals(right);

        public static explicit operator string(DatabaseUserRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseUserRole other && Equals(other);
        public bool Equals(DatabaseUserRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the desired eviction policy for the Redis cluster.
    /// 
    /// - `noeviction`: Don't evict any data, returns error when memory limit is reached.
    /// - `allkeys_lru:` Evict any key, least recently used (LRU) first.
    /// - `allkeys_random`: Evict keys in a random order.
    /// - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
    /// - `volatile_random`: Evict keys with expiration only in a random order.
    /// - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
    /// </summary>
    [EnumType]
    public readonly struct EvictionPolicy : IEquatable<EvictionPolicy>
    {
        private readonly string _value;

        private EvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EvictionPolicy Noeviction { get; } = new EvictionPolicy("noeviction");
        public static EvictionPolicy AllkeysLru { get; } = new EvictionPolicy("allkeys_lru");
        public static EvictionPolicy AllkeysRandom { get; } = new EvictionPolicy("allkeys_random");
        public static EvictionPolicy VolatileLru { get; } = new EvictionPolicy("volatile_lru");
        public static EvictionPolicy VolatileRandom { get; } = new EvictionPolicy("volatile_random");
        public static EvictionPolicy VolatileTtl { get; } = new EvictionPolicy("volatile_ttl");

        public static bool operator ==(EvictionPolicy left, EvictionPolicy right) => left.Equals(right);
        public static bool operator !=(EvictionPolicy left, EvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(EvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EvictionPolicy other && Equals(other);
        public bool Equals(EvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resource that the firewall rule allows to access the database cluster.
    /// </summary>
    [EnumType]
    public readonly struct FirewallRuleType : IEquatable<FirewallRuleType>
    {
        private readonly string _value;

        private FirewallRuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallRuleType Droplet { get; } = new FirewallRuleType("droplet");
        public static FirewallRuleType K8s { get; } = new FirewallRuleType("k8s");
        public static FirewallRuleType IpAddr { get; } = new FirewallRuleType("ip_addr");
        public static FirewallRuleType Tag { get; } = new FirewallRuleType("tag");
        public static FirewallRuleType App { get; } = new FirewallRuleType("app");

        public static bool operator ==(FirewallRuleType left, FirewallRuleType right) => left.Equals(right);
        public static bool operator !=(FirewallRuleType left, FirewallRuleType right) => !left.Equals(right);

        public static explicit operator string(FirewallRuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallRuleType other && Equals(other);
        public bool Equals(FirewallRuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the desired eviction policy for the Redis cluster.
    /// 
    /// - `noeviction`: Don't evict any data, returns error when memory limit is reached.
    /// - `allkeys_lru:` Evict any key, least recently used (LRU) first.
    /// - `allkeys_random`: Evict keys in a random order.
    /// - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
    /// - `volatile_random`: Evict keys with expiration only in a random order.
    /// - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
    /// </summary>
    [EnumType]
    public readonly struct GetDatabasesEvictionPolicyPropertiesEvictionPolicy : IEquatable<GetDatabasesEvictionPolicyPropertiesEvictionPolicy>
    {
        private readonly string _value;

        private GetDatabasesEvictionPolicyPropertiesEvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy Noeviction { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("noeviction");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy AllkeysLru { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("allkeys_lru");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy AllkeysRandom { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("allkeys_random");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy VolatileLru { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("volatile_lru");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy VolatileRandom { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("volatile_random");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy VolatileTtl { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("volatile_ttl");

        public static bool operator ==(GetDatabasesEvictionPolicyPropertiesEvictionPolicy left, GetDatabasesEvictionPolicyPropertiesEvictionPolicy right) => left.Equals(right);
        public static bool operator !=(GetDatabasesEvictionPolicyPropertiesEvictionPolicy left, GetDatabasesEvictionPolicyPropertiesEvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(GetDatabasesEvictionPolicyPropertiesEvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GetDatabasesEvictionPolicyPropertiesEvictionPolicy other && Equals(other);
        public bool Equals(GetDatabasesEvictionPolicyPropertiesEvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage engine for in-memory internal temporary tables.
    /// </summary>
    [EnumType]
    public readonly struct MysqlInternalTmpMemStorageEngine : IEquatable<MysqlInternalTmpMemStorageEngine>
    {
        private readonly string _value;

        private MysqlInternalTmpMemStorageEngine(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MysqlInternalTmpMemStorageEngine TempTable { get; } = new MysqlInternalTmpMemStorageEngine("TempTable");
        public static MysqlInternalTmpMemStorageEngine Memory { get; } = new MysqlInternalTmpMemStorageEngine("MEMORY");

        public static bool operator ==(MysqlInternalTmpMemStorageEngine left, MysqlInternalTmpMemStorageEngine right) => left.Equals(right);
        public static bool operator !=(MysqlInternalTmpMemStorageEngine left, MysqlInternalTmpMemStorageEngine right) => !left.Equals(right);

        public static explicit operator string(MysqlInternalTmpMemStorageEngine value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MysqlInternalTmpMemStorageEngine other && Equals(other);
        public bool Equals(MysqlInternalTmpMemStorageEngine other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the authentication method to be used for connections
    /// to the MySQL user account. The valid values are `mysql_native_password`
    /// or `caching_sha2_password`. If excluded when creating a new user, the
    /// default for the version of MySQL in use will be used. As of MySQL 8.0, the
    /// default is `caching_sha2_password`.
    /// </summary>
    [EnumType]
    public readonly struct MysqlSettingsAuthPlugin : IEquatable<MysqlSettingsAuthPlugin>
    {
        private readonly string _value;

        private MysqlSettingsAuthPlugin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MysqlSettingsAuthPlugin MysqlNativePassword { get; } = new MysqlSettingsAuthPlugin("mysql_native_password");
        public static MysqlSettingsAuthPlugin CachingSha2Password { get; } = new MysqlSettingsAuthPlugin("caching_sha2_password");

        public static bool operator ==(MysqlSettingsAuthPlugin left, MysqlSettingsAuthPlugin right) => left.Equals(right);
        public static bool operator !=(MysqlSettingsAuthPlugin left, MysqlSettingsAuthPlugin right) => !left.Equals(right);

        public static explicit operator string(MysqlSettingsAuthPlugin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MysqlSettingsAuthPlugin other && Equals(other);
        public bool Equals(MysqlSettingsAuthPlugin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the migration.
    /// </summary>
    [EnumType]
    public readonly struct OnlineMigrationStatus : IEquatable<OnlineMigrationStatus>
    {
        private readonly string _value;

        private OnlineMigrationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OnlineMigrationStatus Running { get; } = new OnlineMigrationStatus("running");
        public static OnlineMigrationStatus Canceled { get; } = new OnlineMigrationStatus("canceled");
        public static OnlineMigrationStatus Error { get; } = new OnlineMigrationStatus("error");
        public static OnlineMigrationStatus Done { get; } = new OnlineMigrationStatus("done");

        public static bool operator ==(OnlineMigrationStatus left, OnlineMigrationStatus right) => left.Equals(right);
        public static bool operator !=(OnlineMigrationStatus left, OnlineMigrationStatus right) => !left.Equals(right);

        public static explicit operator string(OnlineMigrationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OnlineMigrationStatus other && Equals(other);
        public bool Equals(OnlineMigrationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PGBouncer pool mode
    /// </summary>
    [EnumType]
    public readonly struct PgbouncerAutodbPoolMode : IEquatable<PgbouncerAutodbPoolMode>
    {
        private readonly string _value;

        private PgbouncerAutodbPoolMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PgbouncerAutodbPoolMode Session { get; } = new PgbouncerAutodbPoolMode("session");
        public static PgbouncerAutodbPoolMode Transaction { get; } = new PgbouncerAutodbPoolMode("transaction");
        public static PgbouncerAutodbPoolMode Statement { get; } = new PgbouncerAutodbPoolMode("statement");

        public static bool operator ==(PgbouncerAutodbPoolMode left, PgbouncerAutodbPoolMode right) => left.Equals(right);
        public static bool operator !=(PgbouncerAutodbPoolMode left, PgbouncerAutodbPoolMode right) => !left.Equals(right);

        public static explicit operator string(PgbouncerAutodbPoolMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgbouncerAutodbPoolMode other && Equals(other);
        public bool Equals(PgbouncerAutodbPoolMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum of parameters to ignore when given in startup packet.
    /// </summary>
    [EnumType]
    public readonly struct PgbouncerIgnoreStartupParametersItem : IEquatable<PgbouncerIgnoreStartupParametersItem>
    {
        private readonly string _value;

        private PgbouncerIgnoreStartupParametersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PgbouncerIgnoreStartupParametersItem ExtraFloatDigits { get; } = new PgbouncerIgnoreStartupParametersItem("extra_float_digits");
        public static PgbouncerIgnoreStartupParametersItem SearchPath { get; } = new PgbouncerIgnoreStartupParametersItem("search_path");

        public static bool operator ==(PgbouncerIgnoreStartupParametersItem left, PgbouncerIgnoreStartupParametersItem right) => left.Equals(right);
        public static bool operator !=(PgbouncerIgnoreStartupParametersItem left, PgbouncerIgnoreStartupParametersItem right) => !left.Equals(right);

        public static explicit operator string(PgbouncerIgnoreStartupParametersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgbouncerIgnoreStartupParametersItem other && Equals(other);
        public bool Equals(PgbouncerIgnoreStartupParametersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
    /// </summary>
    [EnumType]
    public readonly struct PostgresDefaultToastCompression : IEquatable<PostgresDefaultToastCompression>
    {
        private readonly string _value;

        private PostgresDefaultToastCompression(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresDefaultToastCompression Lz4 { get; } = new PostgresDefaultToastCompression("lz4");
        public static PostgresDefaultToastCompression Pglz { get; } = new PostgresDefaultToastCompression("pglz");

        public static bool operator ==(PostgresDefaultToastCompression left, PostgresDefaultToastCompression right) => left.Equals(right);
        public static bool operator !=(PostgresDefaultToastCompression left, PostgresDefaultToastCompression right) => !left.Equals(right);

        public static explicit operator string(PostgresDefaultToastCompression value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresDefaultToastCompression other && Equals(other);
        public bool Equals(PostgresDefaultToastCompression other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Controls the amount of detail written in the server log for each message that is logged.
    /// </summary>
    [EnumType]
    public readonly struct PostgresLogErrorVerbosity : IEquatable<PostgresLogErrorVerbosity>
    {
        private readonly string _value;

        private PostgresLogErrorVerbosity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresLogErrorVerbosity Terse { get; } = new PostgresLogErrorVerbosity("TERSE");
        public static PostgresLogErrorVerbosity Default { get; } = new PostgresLogErrorVerbosity("DEFAULT");
        public static PostgresLogErrorVerbosity Verbose { get; } = new PostgresLogErrorVerbosity("VERBOSE");

        public static bool operator ==(PostgresLogErrorVerbosity left, PostgresLogErrorVerbosity right) => left.Equals(right);
        public static bool operator !=(PostgresLogErrorVerbosity left, PostgresLogErrorVerbosity right) => !left.Equals(right);

        public static explicit operator string(PostgresLogErrorVerbosity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresLogErrorVerbosity other && Equals(other);
        public bool Equals(PostgresLogErrorVerbosity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selects one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze, etc.
    /// </summary>
    [EnumType]
    public readonly struct PostgresLogLinePrefix : IEquatable<PostgresLogLinePrefix>
    {
        private readonly string _value;

        private PostgresLogLinePrefix(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresLogLinePrefix Pidpuserudbdappaclienth { get; } = new PostgresLogLinePrefix("pid=%p,user=%u,db=%d,app=%a,client=%h");
        public static PostgresLogLinePrefix Mpquserudbdappa { get; } = new PostgresLogLinePrefix("%m [%p] %q[user=%u,db=%d,app=%a]");
        public static PostgresLogLinePrefix Tpl1Userudbdappaclienth { get; } = new PostgresLogLinePrefix("%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h");

        public static bool operator ==(PostgresLogLinePrefix left, PostgresLogLinePrefix right) => left.Equals(right);
        public static bool operator !=(PostgresLogLinePrefix left, PostgresLogLinePrefix right) => !left.Equals(right);

        public static explicit operator string(PostgresLogLinePrefix value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresLogLinePrefix other && Equals(other);
        public bool Equals(PostgresLogLinePrefix other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Controls which statements are counted. Specify 'top' to track top-level statements (those issued directly by clients), 'all' to also track nested statements (such as statements invoked within functions), or 'none' to disable statement statistics collection. The default value is top.
    /// </summary>
    [EnumType]
    public readonly struct PostgresPgStatStatementsTrack : IEquatable<PostgresPgStatStatementsTrack>
    {
        private readonly string _value;

        private PostgresPgStatStatementsTrack(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresPgStatStatementsTrack All { get; } = new PostgresPgStatStatementsTrack("all");
        public static PostgresPgStatStatementsTrack Top { get; } = new PostgresPgStatStatementsTrack("top");
        public static PostgresPgStatStatementsTrack None { get; } = new PostgresPgStatStatementsTrack("none");

        public static bool operator ==(PostgresPgStatStatementsTrack left, PostgresPgStatStatementsTrack right) => left.Equals(right);
        public static bool operator !=(PostgresPgStatStatementsTrack left, PostgresPgStatStatementsTrack right) => !left.Equals(right);

        public static explicit operator string(PostgresPgStatStatementsTrack value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresPgStatStatementsTrack other && Equals(other);
        public bool Equals(PostgresPgStatStatementsTrack other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Synchronous replication type. Note that the service plan also needs to support synchronous replication.
    /// </summary>
    [EnumType]
    public readonly struct PostgresSynchronousReplication : IEquatable<PostgresSynchronousReplication>
    {
        private readonly string _value;

        private PostgresSynchronousReplication(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresSynchronousReplication Off { get; } = new PostgresSynchronousReplication("off");
        public static PostgresSynchronousReplication Quorum { get; } = new PostgresSynchronousReplication("quorum");

        public static bool operator ==(PostgresSynchronousReplication left, PostgresSynchronousReplication right) => left.Equals(right);
        public static bool operator !=(PostgresSynchronousReplication left, PostgresSynchronousReplication right) => !left.Equals(right);

        public static explicit operator string(PostgresSynchronousReplication value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresSynchronousReplication other && Equals(other);
        public bool Equals(PostgresSynchronousReplication other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Record commit time of transactions.
    /// </summary>
    [EnumType]
    public readonly struct PostgresTrackCommitTimestamp : IEquatable<PostgresTrackCommitTimestamp>
    {
        private readonly string _value;

        private PostgresTrackCommitTimestamp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresTrackCommitTimestamp Off { get; } = new PostgresTrackCommitTimestamp("off");
        public static PostgresTrackCommitTimestamp On { get; } = new PostgresTrackCommitTimestamp("on");

        public static bool operator ==(PostgresTrackCommitTimestamp left, PostgresTrackCommitTimestamp right) => left.Equals(right);
        public static bool operator !=(PostgresTrackCommitTimestamp left, PostgresTrackCommitTimestamp right) => !left.Equals(right);

        public static explicit operator string(PostgresTrackCommitTimestamp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresTrackCommitTimestamp other && Equals(other);
        public bool Equals(PostgresTrackCommitTimestamp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables tracking of function call counts and time used.
    /// </summary>
    [EnumType]
    public readonly struct PostgresTrackFunctions : IEquatable<PostgresTrackFunctions>
    {
        private readonly string _value;

        private PostgresTrackFunctions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresTrackFunctions All { get; } = new PostgresTrackFunctions("all");
        public static PostgresTrackFunctions Pl { get; } = new PostgresTrackFunctions("pl");
        public static PostgresTrackFunctions None { get; } = new PostgresTrackFunctions("none");

        public static bool operator ==(PostgresTrackFunctions left, PostgresTrackFunctions right) => left.Equals(right);
        public static bool operator !=(PostgresTrackFunctions left, PostgresTrackFunctions right) => !left.Equals(right);

        public static explicit operator string(PostgresTrackFunctions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresTrackFunctions other && Equals(other);
        public bool Equals(PostgresTrackFunctions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
    /// </summary>
    [EnumType]
    public readonly struct PostgresTrackIoTiming : IEquatable<PostgresTrackIoTiming>
    {
        private readonly string _value;

        private PostgresTrackIoTiming(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PostgresTrackIoTiming Off { get; } = new PostgresTrackIoTiming("off");
        public static PostgresTrackIoTiming On { get; } = new PostgresTrackIoTiming("on");

        public static bool operator ==(PostgresTrackIoTiming left, PostgresTrackIoTiming right) => left.Equals(right);
        public static bool operator !=(PostgresTrackIoTiming left, PostgresTrackIoTiming right) => !left.Equals(right);

        public static explicit operator string(PostgresTrackIoTiming value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PostgresTrackIoTiming other && Equals(other);
        public bool Equals(PostgresTrackIoTiming other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
    /// </summary>
    [EnumType]
    public readonly struct RedisRedisAclChannelsDefault : IEquatable<RedisRedisAclChannelsDefault>
    {
        private readonly string _value;

        private RedisRedisAclChannelsDefault(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedisRedisAclChannelsDefault Allchannels { get; } = new RedisRedisAclChannelsDefault("allchannels");
        public static RedisRedisAclChannelsDefault Resetchannels { get; } = new RedisRedisAclChannelsDefault("resetchannels");

        public static bool operator ==(RedisRedisAclChannelsDefault left, RedisRedisAclChannelsDefault right) => left.Equals(right);
        public static bool operator !=(RedisRedisAclChannelsDefault left, RedisRedisAclChannelsDefault right) => !left.Equals(right);

        public static explicit operator string(RedisRedisAclChannelsDefault value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedisRedisAclChannelsDefault other && Equals(other);
        public bool Equals(RedisRedisAclChannelsDefault other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the desired eviction policy for the Redis cluster.
    /// 
    /// - `noeviction`: Don't evict any data, returns error when memory limit is reached.
    /// - `allkeys_lru:` Evict any key, least recently used (LRU) first.
    /// - `allkeys_random`: Evict keys in a random order.
    /// - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
    /// - `volatile_random`: Evict keys with expiration only in a random order.
    /// - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
    /// </summary>
    [EnumType]
    public readonly struct RedisRedisMaxmemoryPolicy : IEquatable<RedisRedisMaxmemoryPolicy>
    {
        private readonly string _value;

        private RedisRedisMaxmemoryPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedisRedisMaxmemoryPolicy Noeviction { get; } = new RedisRedisMaxmemoryPolicy("noeviction");
        public static RedisRedisMaxmemoryPolicy AllkeysLru { get; } = new RedisRedisMaxmemoryPolicy("allkeys_lru");
        public static RedisRedisMaxmemoryPolicy AllkeysRandom { get; } = new RedisRedisMaxmemoryPolicy("allkeys_random");
        public static RedisRedisMaxmemoryPolicy VolatileLru { get; } = new RedisRedisMaxmemoryPolicy("volatile_lru");
        public static RedisRedisMaxmemoryPolicy VolatileRandom { get; } = new RedisRedisMaxmemoryPolicy("volatile_random");
        public static RedisRedisMaxmemoryPolicy VolatileTtl { get; } = new RedisRedisMaxmemoryPolicy("volatile_ttl");

        public static bool operator ==(RedisRedisMaxmemoryPolicy left, RedisRedisMaxmemoryPolicy right) => left.Equals(right);
        public static bool operator !=(RedisRedisMaxmemoryPolicy left, RedisRedisMaxmemoryPolicy right) => !left.Equals(right);

        public static explicit operator string(RedisRedisMaxmemoryPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedisRedisMaxmemoryPolicy other && Equals(other);
        public bool Equals(RedisRedisMaxmemoryPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
    /// </summary>
    [EnumType]
    public readonly struct RedisRedisPersistence : IEquatable<RedisRedisPersistence>
    {
        private readonly string _value;

        private RedisRedisPersistence(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedisRedisPersistence Off { get; } = new RedisRedisPersistence("off");
        public static RedisRedisPersistence Rdb { get; } = new RedisRedisPersistence("rdb");

        public static bool operator ==(RedisRedisPersistence left, RedisRedisPersistence right) => left.Equals(right);
        public static bool operator !=(RedisRedisPersistence left, RedisRedisPersistence right) => !left.Equals(right);

        public static explicit operator string(RedisRedisPersistence value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedisRedisPersistence other && Equals(other);
        public bool Equals(RedisRedisPersistence other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the migration.
    /// </summary>
    [EnumType]
    public readonly struct Status : IEquatable<Status>
    {
        private readonly string _value;

        private Status(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Status Running { get; } = new Status("running");
        public static Status Canceled { get; } = new Status("canceled");
        public static Status Error { get; } = new Status("error");
        public static Status Done { get; } = new Status("done");

        public static bool operator ==(Status left, Status right) => left.Equals(right);
        public static bool operator !=(Status left, Status right) => !left.Equals(right);

        public static explicit operator string(Status value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Status other && Equals(other);
        public bool Equals(Status other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
