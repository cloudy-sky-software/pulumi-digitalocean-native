// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.DigitalOceanNative.DatabasesV2
{
    /// <summary>
    /// Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
    /// </summary>
    [EnumType]
    public readonly struct CreategresDefaultToastCompression : IEquatable<CreategresDefaultToastCompression>
    {
        private readonly string _value;

        private CreategresDefaultToastCompression(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresDefaultToastCompression Lz4 { get; } = new CreategresDefaultToastCompression("lz4");
        public static CreategresDefaultToastCompression Pglz { get; } = new CreategresDefaultToastCompression("pglz");

        public static bool operator ==(CreategresDefaultToastCompression left, CreategresDefaultToastCompression right) => left.Equals(right);
        public static bool operator !=(CreategresDefaultToastCompression left, CreategresDefaultToastCompression right) => !left.Equals(right);

        public static explicit operator string(CreategresDefaultToastCompression value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresDefaultToastCompression other && Equals(other);
        public bool Equals(CreategresDefaultToastCompression other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Controls the amount of detail written in the server log for each message that is logged.
    /// </summary>
    [EnumType]
    public readonly struct CreategresLogErrorVerbosity : IEquatable<CreategresLogErrorVerbosity>
    {
        private readonly string _value;

        private CreategresLogErrorVerbosity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresLogErrorVerbosity Terse { get; } = new CreategresLogErrorVerbosity("TERSE");
        public static CreategresLogErrorVerbosity Default { get; } = new CreategresLogErrorVerbosity("DEFAULT");
        public static CreategresLogErrorVerbosity Verbose { get; } = new CreategresLogErrorVerbosity("VERBOSE");

        public static bool operator ==(CreategresLogErrorVerbosity left, CreategresLogErrorVerbosity right) => left.Equals(right);
        public static bool operator !=(CreategresLogErrorVerbosity left, CreategresLogErrorVerbosity right) => !left.Equals(right);

        public static explicit operator string(CreategresLogErrorVerbosity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresLogErrorVerbosity other && Equals(other);
        public bool Equals(CreategresLogErrorVerbosity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selects one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze, etc.
    /// </summary>
    [EnumType]
    public readonly struct CreategresLogLinePrefix : IEquatable<CreategresLogLinePrefix>
    {
        private readonly string _value;

        private CreategresLogLinePrefix(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresLogLinePrefix Pidpuserudbdappaclienth { get; } = new CreategresLogLinePrefix("pid=%p,user=%u,db=%d,app=%a,client=%h");
        public static CreategresLogLinePrefix Mpquserudbdappa { get; } = new CreategresLogLinePrefix("%m [%p] %q[user=%u,db=%d,app=%a]");
        public static CreategresLogLinePrefix Tpl1Userudbdappaclienth { get; } = new CreategresLogLinePrefix("%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h");

        public static bool operator ==(CreategresLogLinePrefix left, CreategresLogLinePrefix right) => left.Equals(right);
        public static bool operator !=(CreategresLogLinePrefix left, CreategresLogLinePrefix right) => !left.Equals(right);

        public static explicit operator string(CreategresLogLinePrefix value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresLogLinePrefix other && Equals(other);
        public bool Equals(CreategresLogLinePrefix other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Controls which statements are counted. Specify 'top' to track top-level statements (those issued directly by clients), 'all' to also track nested statements (such as statements invoked within functions), or 'none' to disable statement statistics collection. The default value is top.
    /// </summary>
    [EnumType]
    public readonly struct CreategresPgStatStatementsTrack : IEquatable<CreategresPgStatStatementsTrack>
    {
        private readonly string _value;

        private CreategresPgStatStatementsTrack(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresPgStatStatementsTrack All { get; } = new CreategresPgStatStatementsTrack("all");
        public static CreategresPgStatStatementsTrack Top { get; } = new CreategresPgStatStatementsTrack("top");
        public static CreategresPgStatStatementsTrack None { get; } = new CreategresPgStatStatementsTrack("none");

        public static bool operator ==(CreategresPgStatStatementsTrack left, CreategresPgStatStatementsTrack right) => left.Equals(right);
        public static bool operator !=(CreategresPgStatStatementsTrack left, CreategresPgStatStatementsTrack right) => !left.Equals(right);

        public static explicit operator string(CreategresPgStatStatementsTrack value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresPgStatStatementsTrack other && Equals(other);
        public bool Equals(CreategresPgStatStatementsTrack other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Synchronous replication type. Note that the service plan also needs to support synchronous replication.
    /// </summary>
    [EnumType]
    public readonly struct CreategresSynchronousReplication : IEquatable<CreategresSynchronousReplication>
    {
        private readonly string _value;

        private CreategresSynchronousReplication(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresSynchronousReplication Off { get; } = new CreategresSynchronousReplication("off");
        public static CreategresSynchronousReplication Quorum { get; } = new CreategresSynchronousReplication("quorum");

        public static bool operator ==(CreategresSynchronousReplication left, CreategresSynchronousReplication right) => left.Equals(right);
        public static bool operator !=(CreategresSynchronousReplication left, CreategresSynchronousReplication right) => !left.Equals(right);

        public static explicit operator string(CreategresSynchronousReplication value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresSynchronousReplication other && Equals(other);
        public bool Equals(CreategresSynchronousReplication other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Record commit time of transactions.
    /// </summary>
    [EnumType]
    public readonly struct CreategresTrackCommitTimestamp : IEquatable<CreategresTrackCommitTimestamp>
    {
        private readonly string _value;

        private CreategresTrackCommitTimestamp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresTrackCommitTimestamp Off { get; } = new CreategresTrackCommitTimestamp("off");
        public static CreategresTrackCommitTimestamp On { get; } = new CreategresTrackCommitTimestamp("on");

        public static bool operator ==(CreategresTrackCommitTimestamp left, CreategresTrackCommitTimestamp right) => left.Equals(right);
        public static bool operator !=(CreategresTrackCommitTimestamp left, CreategresTrackCommitTimestamp right) => !left.Equals(right);

        public static explicit operator string(CreategresTrackCommitTimestamp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresTrackCommitTimestamp other && Equals(other);
        public bool Equals(CreategresTrackCommitTimestamp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables tracking of function call counts and time used.
    /// </summary>
    [EnumType]
    public readonly struct CreategresTrackFunctions : IEquatable<CreategresTrackFunctions>
    {
        private readonly string _value;

        private CreategresTrackFunctions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresTrackFunctions All { get; } = new CreategresTrackFunctions("all");
        public static CreategresTrackFunctions Pl { get; } = new CreategresTrackFunctions("pl");
        public static CreategresTrackFunctions None { get; } = new CreategresTrackFunctions("none");

        public static bool operator ==(CreategresTrackFunctions left, CreategresTrackFunctions right) => left.Equals(right);
        public static bool operator !=(CreategresTrackFunctions left, CreategresTrackFunctions right) => !left.Equals(right);

        public static explicit operator string(CreategresTrackFunctions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresTrackFunctions other && Equals(other);
        public bool Equals(CreategresTrackFunctions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
    /// </summary>
    [EnumType]
    public readonly struct CreategresTrackIoTiming : IEquatable<CreategresTrackIoTiming>
    {
        private readonly string _value;

        private CreategresTrackIoTiming(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreategresTrackIoTiming Off { get; } = new CreategresTrackIoTiming("off");
        public static CreategresTrackIoTiming On { get; } = new CreategresTrackIoTiming("on");

        public static bool operator ==(CreategresTrackIoTiming left, CreategresTrackIoTiming right) => left.Equals(right);
        public static bool operator !=(CreategresTrackIoTiming left, CreategresTrackIoTiming right) => !left.Equals(right);

        public static explicit operator string(CreategresTrackIoTiming value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreategresTrackIoTiming other && Equals(other);
        public bool Equals(CreategresTrackIoTiming other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A slug representing the database engine used for the cluster. The possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb" for MongoDB.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseClusterEngine : IEquatable<DatabaseClusterEngine>
    {
        private readonly string _value;

        private DatabaseClusterEngine(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseClusterEngine Pg { get; } = new DatabaseClusterEngine("pg");
        public static DatabaseClusterEngine Mysql { get; } = new DatabaseClusterEngine("mysql");
        public static DatabaseClusterEngine Redis { get; } = new DatabaseClusterEngine("redis");
        public static DatabaseClusterEngine Mongodb { get; } = new DatabaseClusterEngine("mongodb");

        public static bool operator ==(DatabaseClusterEngine left, DatabaseClusterEngine right) => left.Equals(right);
        public static bool operator !=(DatabaseClusterEngine left, DatabaseClusterEngine right) => !left.Equals(right);

        public static explicit operator string(DatabaseClusterEngine value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseClusterEngine other && Equals(other);
        public bool Equals(DatabaseClusterEngine other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string representing the current status of the database cluster.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseClusterStatus : IEquatable<DatabaseClusterStatus>
    {
        private readonly string _value;

        private DatabaseClusterStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseClusterStatus Creating { get; } = new DatabaseClusterStatus("creating");
        public static DatabaseClusterStatus Online { get; } = new DatabaseClusterStatus("online");
        public static DatabaseClusterStatus Resizing { get; } = new DatabaseClusterStatus("resizing");
        public static DatabaseClusterStatus Migrating { get; } = new DatabaseClusterStatus("migrating");
        public static DatabaseClusterStatus Forking { get; } = new DatabaseClusterStatus("forking");

        public static bool operator ==(DatabaseClusterStatus left, DatabaseClusterStatus right) => left.Equals(right);
        public static bool operator !=(DatabaseClusterStatus left, DatabaseClusterStatus right) => !left.Equals(right);

        public static explicit operator string(DatabaseClusterStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseClusterStatus other && Equals(other);
        public bool Equals(DatabaseClusterStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string representing the current status of the database cluster.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseReplicaStatus : IEquatable<DatabaseReplicaStatus>
    {
        private readonly string _value;

        private DatabaseReplicaStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseReplicaStatus Creating { get; } = new DatabaseReplicaStatus("creating");
        public static DatabaseReplicaStatus Online { get; } = new DatabaseReplicaStatus("online");
        public static DatabaseReplicaStatus Resizing { get; } = new DatabaseReplicaStatus("resizing");
        public static DatabaseReplicaStatus Migrating { get; } = new DatabaseReplicaStatus("migrating");
        public static DatabaseReplicaStatus Forking { get; } = new DatabaseReplicaStatus("forking");

        public static bool operator ==(DatabaseReplicaStatus left, DatabaseReplicaStatus right) => left.Equals(right);
        public static bool operator !=(DatabaseReplicaStatus left, DatabaseReplicaStatus right) => !left.Equals(right);

        public static explicit operator string(DatabaseReplicaStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseReplicaStatus other && Equals(other);
        public bool Equals(DatabaseReplicaStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string representing the database user's role. The value will be either
    /// "primary" or "normal".
    /// </summary>
    [EnumType]
    public readonly struct DatabaseUserRole : IEquatable<DatabaseUserRole>
    {
        private readonly string _value;

        private DatabaseUserRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseUserRole Primary { get; } = new DatabaseUserRole("primary");
        public static DatabaseUserRole Normal { get; } = new DatabaseUserRole("normal");

        public static bool operator ==(DatabaseUserRole left, DatabaseUserRole right) => left.Equals(right);
        public static bool operator !=(DatabaseUserRole left, DatabaseUserRole right) => !left.Equals(right);

        public static explicit operator string(DatabaseUserRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseUserRole other && Equals(other);
        public bool Equals(DatabaseUserRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the desired eviction policy for the Redis cluster.
    /// 
    /// - `noeviction`: Don't evict any data, returns error when memory limit is reached.
    /// - `allkeys_lru:` Evict any key, least recently used (LRU) first.
    /// - `allkeys_random`: Evict keys in a random order.
    /// - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
    /// - `volatile_random`: Evict keys with expiration only in a random order.
    /// - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
    /// </summary>
    [EnumType]
    public readonly struct EvictionPolicy : IEquatable<EvictionPolicy>
    {
        private readonly string _value;

        private EvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EvictionPolicy Noeviction { get; } = new EvictionPolicy("noeviction");
        public static EvictionPolicy AllkeysLru { get; } = new EvictionPolicy("allkeys_lru");
        public static EvictionPolicy AllkeysRandom { get; } = new EvictionPolicy("allkeys_random");
        public static EvictionPolicy VolatileLru { get; } = new EvictionPolicy("volatile_lru");
        public static EvictionPolicy VolatileRandom { get; } = new EvictionPolicy("volatile_random");
        public static EvictionPolicy VolatileTtl { get; } = new EvictionPolicy("volatile_ttl");

        public static bool operator ==(EvictionPolicy left, EvictionPolicy right) => left.Equals(right);
        public static bool operator !=(EvictionPolicy left, EvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(EvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EvictionPolicy other && Equals(other);
        public bool Equals(EvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resource that the firewall rule allows to access the database cluster.
    /// </summary>
    [EnumType]
    public readonly struct FirewallRuleType : IEquatable<FirewallRuleType>
    {
        private readonly string _value;

        private FirewallRuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallRuleType Droplet { get; } = new FirewallRuleType("droplet");
        public static FirewallRuleType K8s { get; } = new FirewallRuleType("k8s");
        public static FirewallRuleType IpAddr { get; } = new FirewallRuleType("ip_addr");
        public static FirewallRuleType Tag { get; } = new FirewallRuleType("tag");
        public static FirewallRuleType App { get; } = new FirewallRuleType("app");

        public static bool operator ==(FirewallRuleType left, FirewallRuleType right) => left.Equals(right);
        public static bool operator !=(FirewallRuleType left, FirewallRuleType right) => !left.Equals(right);

        public static explicit operator string(FirewallRuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallRuleType other && Equals(other);
        public bool Equals(FirewallRuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the desired eviction policy for the Redis cluster.
    /// 
    /// - `noeviction`: Don't evict any data, returns error when memory limit is reached.
    /// - `allkeys_lru:` Evict any key, least recently used (LRU) first.
    /// - `allkeys_random`: Evict keys in a random order.
    /// - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
    /// - `volatile_random`: Evict keys with expiration only in a random order.
    /// - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
    /// </summary>
    [EnumType]
    public readonly struct GetDatabasesEvictionPolicyPropertiesEvictionPolicy : IEquatable<GetDatabasesEvictionPolicyPropertiesEvictionPolicy>
    {
        private readonly string _value;

        private GetDatabasesEvictionPolicyPropertiesEvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy Noeviction { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("noeviction");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy AllkeysLru { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("allkeys_lru");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy AllkeysRandom { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("allkeys_random");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy VolatileLru { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("volatile_lru");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy VolatileRandom { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("volatile_random");
        public static GetDatabasesEvictionPolicyPropertiesEvictionPolicy VolatileTtl { get; } = new GetDatabasesEvictionPolicyPropertiesEvictionPolicy("volatile_ttl");

        public static bool operator ==(GetDatabasesEvictionPolicyPropertiesEvictionPolicy left, GetDatabasesEvictionPolicyPropertiesEvictionPolicy right) => left.Equals(right);
        public static bool operator !=(GetDatabasesEvictionPolicyPropertiesEvictionPolicy left, GetDatabasesEvictionPolicyPropertiesEvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(GetDatabasesEvictionPolicyPropertiesEvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GetDatabasesEvictionPolicyPropertiesEvictionPolicy other && Equals(other);
        public bool Equals(GetDatabasesEvictionPolicyPropertiesEvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage engine for in-memory internal temporary tables.
    /// </summary>
    [EnumType]
    public readonly struct MysqlInternalTmpMemStorageEngine : IEquatable<MysqlInternalTmpMemStorageEngine>
    {
        private readonly string _value;

        private MysqlInternalTmpMemStorageEngine(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MysqlInternalTmpMemStorageEngine TempTable { get; } = new MysqlInternalTmpMemStorageEngine("TempTable");
        public static MysqlInternalTmpMemStorageEngine Memory { get; } = new MysqlInternalTmpMemStorageEngine("MEMORY");

        public static bool operator ==(MysqlInternalTmpMemStorageEngine left, MysqlInternalTmpMemStorageEngine right) => left.Equals(right);
        public static bool operator !=(MysqlInternalTmpMemStorageEngine left, MysqlInternalTmpMemStorageEngine right) => !left.Equals(right);

        public static explicit operator string(MysqlInternalTmpMemStorageEngine value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MysqlInternalTmpMemStorageEngine other && Equals(other);
        public bool Equals(MysqlInternalTmpMemStorageEngine other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the authentication method to be used for connections
    /// to the MySQL user account. The valid values are `mysql_native_password`
    /// or `caching_sha2_password`. If excluded when creating a new user, the
    /// default for the version of MySQL in use will be used. As of MySQL 8.0, the
    /// default is `caching_sha2_password`.
    /// </summary>
    [EnumType]
    public readonly struct MysqlSettingsAuthPlugin : IEquatable<MysqlSettingsAuthPlugin>
    {
        private readonly string _value;

        private MysqlSettingsAuthPlugin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MysqlSettingsAuthPlugin MysqlNativePassword { get; } = new MysqlSettingsAuthPlugin("mysql_native_password");
        public static MysqlSettingsAuthPlugin CachingSha2Password { get; } = new MysqlSettingsAuthPlugin("caching_sha2_password");

        public static bool operator ==(MysqlSettingsAuthPlugin left, MysqlSettingsAuthPlugin right) => left.Equals(right);
        public static bool operator !=(MysqlSettingsAuthPlugin left, MysqlSettingsAuthPlugin right) => !left.Equals(right);

        public static explicit operator string(MysqlSettingsAuthPlugin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MysqlSettingsAuthPlugin other && Equals(other);
        public bool Equals(MysqlSettingsAuthPlugin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the migration.
    /// </summary>
    [EnumType]
    public readonly struct OnlineMigrationStatus : IEquatable<OnlineMigrationStatus>
    {
        private readonly string _value;

        private OnlineMigrationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OnlineMigrationStatus Running { get; } = new OnlineMigrationStatus("running");
        public static OnlineMigrationStatus Canceled { get; } = new OnlineMigrationStatus("canceled");
        public static OnlineMigrationStatus Error { get; } = new OnlineMigrationStatus("error");
        public static OnlineMigrationStatus Done { get; } = new OnlineMigrationStatus("done");

        public static bool operator ==(OnlineMigrationStatus left, OnlineMigrationStatus right) => left.Equals(right);
        public static bool operator !=(OnlineMigrationStatus left, OnlineMigrationStatus right) => !left.Equals(right);

        public static explicit operator string(OnlineMigrationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OnlineMigrationStatus other && Equals(other);
        public bool Equals(OnlineMigrationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PGBouncer pool mode
    /// </summary>
    [EnumType]
    public readonly struct PgbouncerAutodbPoolMode : IEquatable<PgbouncerAutodbPoolMode>
    {
        private readonly string _value;

        private PgbouncerAutodbPoolMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PgbouncerAutodbPoolMode Session { get; } = new PgbouncerAutodbPoolMode("session");
        public static PgbouncerAutodbPoolMode Transaction { get; } = new PgbouncerAutodbPoolMode("transaction");
        public static PgbouncerAutodbPoolMode Statement { get; } = new PgbouncerAutodbPoolMode("statement");

        public static bool operator ==(PgbouncerAutodbPoolMode left, PgbouncerAutodbPoolMode right) => left.Equals(right);
        public static bool operator !=(PgbouncerAutodbPoolMode left, PgbouncerAutodbPoolMode right) => !left.Equals(right);

        public static explicit operator string(PgbouncerAutodbPoolMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgbouncerAutodbPoolMode other && Equals(other);
        public bool Equals(PgbouncerAutodbPoolMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum of parameters to ignore when given in startup packet.
    /// </summary>
    [EnumType]
    public readonly struct PgbouncerIgnoreStartupParametersItem : IEquatable<PgbouncerIgnoreStartupParametersItem>
    {
        private readonly string _value;

        private PgbouncerIgnoreStartupParametersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PgbouncerIgnoreStartupParametersItem ExtraFloatDigits { get; } = new PgbouncerIgnoreStartupParametersItem("extra_float_digits");
        public static PgbouncerIgnoreStartupParametersItem SearchPath { get; } = new PgbouncerIgnoreStartupParametersItem("search_path");

        public static bool operator ==(PgbouncerIgnoreStartupParametersItem left, PgbouncerIgnoreStartupParametersItem right) => left.Equals(right);
        public static bool operator !=(PgbouncerIgnoreStartupParametersItem left, PgbouncerIgnoreStartupParametersItem right) => !left.Equals(right);

        public static explicit operator string(PgbouncerIgnoreStartupParametersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgbouncerIgnoreStartupParametersItem other && Equals(other);
        public bool Equals(PgbouncerIgnoreStartupParametersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
    /// </summary>
    [EnumType]
    public readonly struct RedisRedisAclChannelsDefault : IEquatable<RedisRedisAclChannelsDefault>
    {
        private readonly string _value;

        private RedisRedisAclChannelsDefault(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedisRedisAclChannelsDefault Allchannels { get; } = new RedisRedisAclChannelsDefault("allchannels");
        public static RedisRedisAclChannelsDefault Resetchannels { get; } = new RedisRedisAclChannelsDefault("resetchannels");

        public static bool operator ==(RedisRedisAclChannelsDefault left, RedisRedisAclChannelsDefault right) => left.Equals(right);
        public static bool operator !=(RedisRedisAclChannelsDefault left, RedisRedisAclChannelsDefault right) => !left.Equals(right);

        public static explicit operator string(RedisRedisAclChannelsDefault value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedisRedisAclChannelsDefault other && Equals(other);
        public bool Equals(RedisRedisAclChannelsDefault other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string specifying the desired eviction policy for the Redis cluster.
    /// 
    /// - `noeviction`: Don't evict any data, returns error when memory limit is reached.
    /// - `allkeys_lru:` Evict any key, least recently used (LRU) first.
    /// - `allkeys_random`: Evict keys in a random order.
    /// - `volatile_lru`: Evict keys with expiration only, least recently used (LRU) first.
    /// - `volatile_random`: Evict keys with expiration only in a random order.
    /// - `volatile_ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.
    /// </summary>
    [EnumType]
    public readonly struct RedisRedisMaxmemoryPolicy : IEquatable<RedisRedisMaxmemoryPolicy>
    {
        private readonly string _value;

        private RedisRedisMaxmemoryPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedisRedisMaxmemoryPolicy Noeviction { get; } = new RedisRedisMaxmemoryPolicy("noeviction");
        public static RedisRedisMaxmemoryPolicy AllkeysLru { get; } = new RedisRedisMaxmemoryPolicy("allkeys_lru");
        public static RedisRedisMaxmemoryPolicy AllkeysRandom { get; } = new RedisRedisMaxmemoryPolicy("allkeys_random");
        public static RedisRedisMaxmemoryPolicy VolatileLru { get; } = new RedisRedisMaxmemoryPolicy("volatile_lru");
        public static RedisRedisMaxmemoryPolicy VolatileRandom { get; } = new RedisRedisMaxmemoryPolicy("volatile_random");
        public static RedisRedisMaxmemoryPolicy VolatileTtl { get; } = new RedisRedisMaxmemoryPolicy("volatile_ttl");

        public static bool operator ==(RedisRedisMaxmemoryPolicy left, RedisRedisMaxmemoryPolicy right) => left.Equals(right);
        public static bool operator !=(RedisRedisMaxmemoryPolicy left, RedisRedisMaxmemoryPolicy right) => !left.Equals(right);

        public static explicit operator string(RedisRedisMaxmemoryPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedisRedisMaxmemoryPolicy other && Equals(other);
        public bool Equals(RedisRedisMaxmemoryPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
    /// </summary>
    [EnumType]
    public readonly struct RedisRedisPersistence : IEquatable<RedisRedisPersistence>
    {
        private readonly string _value;

        private RedisRedisPersistence(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedisRedisPersistence Off { get; } = new RedisRedisPersistence("off");
        public static RedisRedisPersistence Rdb { get; } = new RedisRedisPersistence("rdb");

        public static bool operator ==(RedisRedisPersistence left, RedisRedisPersistence right) => left.Equals(right);
        public static bool operator !=(RedisRedisPersistence left, RedisRedisPersistence right) => !left.Equals(right);

        public static explicit operator string(RedisRedisPersistence value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedisRedisPersistence other && Equals(other);
        public bool Equals(RedisRedisPersistence other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
