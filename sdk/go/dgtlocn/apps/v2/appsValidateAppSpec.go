// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"context"
	"reflect"

	"errors"
	"github.com/cloudy-sky-software/pulumi-digitalocean-native/sdk/go/dgtlocn/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AppsValidateAppSpec struct {
	pulumi.CustomResourceState

	// The monthly cost of the proposed app in USD using the next pricing plan tier. For example, if you propose an app that uses the Basic tier, the `app_tier_upgrade_cost` field displays the monthly cost of the app if it were to use the Professional tier. If the proposed app already uses the most expensive tier, the field is empty.
	AppCost pulumi.IntPtrOutput `pulumi:"appCost"`
	// An optional ID of an existing app. If set, the spec will be treated as a proposed update to the specified app. The existing app is not modified using this method.
	AppId pulumi.StringPtrOutput `pulumi:"appId"`
	// Indicates whether the app is a static app.
	AppIsStatic pulumi.BoolPtrOutput `pulumi:"appIsStatic"`
	// Indicates whether the app name is available.
	AppNameAvailable pulumi.BoolPtrOutput `pulumi:"appNameAvailable"`
	// The suggested name if the proposed app name is unavailable.
	AppNameSuggestion pulumi.StringPtrOutput `pulumi:"appNameSuggestion"`
	// The monthly cost of the proposed app in USD using the previous pricing plan tier. For example, if you propose an app that uses the Professional tier, the `app_tier_downgrade_cost` field displays the monthly cost of the app if it were to use the Basic tier. If the proposed app already uses the lest expensive tier, the field is empty.
	AppTierDowngradeCost pulumi.IntPtrOutput `pulumi:"appTierDowngradeCost"`
	// The maximum number of free static apps the account can have. We will charge you for any additional static apps.
	ExistingStaticApps pulumi.StringPtrOutput `pulumi:"existingStaticApps"`
	// The desired configuration of an application.
	Spec AppSpecOutput `pulumi:"spec"`
}

// NewAppsValidateAppSpec registers a new resource with the given unique name, arguments, and options.
func NewAppsValidateAppSpec(ctx *pulumi.Context,
	name string, args *AppsValidateAppSpecArgs, opts ...pulumi.ResourceOption) (*AppsValidateAppSpec, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Spec == nil {
		return nil, errors.New("invalid value for required argument 'Spec'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AppsValidateAppSpec
	err := ctx.RegisterResource("digitalocean-native:apps/v2:AppsValidateAppSpec", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAppsValidateAppSpec gets an existing AppsValidateAppSpec resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAppsValidateAppSpec(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AppsValidateAppSpecState, opts ...pulumi.ResourceOption) (*AppsValidateAppSpec, error) {
	var resource AppsValidateAppSpec
	err := ctx.ReadResource("digitalocean-native:apps/v2:AppsValidateAppSpec", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AppsValidateAppSpec resources.
type appsValidateAppSpecState struct {
}

type AppsValidateAppSpecState struct {
}

func (AppsValidateAppSpecState) ElementType() reflect.Type {
	return reflect.TypeOf((*appsValidateAppSpecState)(nil)).Elem()
}

type appsValidateAppSpecArgs struct {
	// An optional ID of an existing app. If set, the spec will be treated as a proposed update to the specified app. The existing app is not modified using this method.
	AppId *string `pulumi:"appId"`
	// The desired configuration of an application.
	Spec AppSpec `pulumi:"spec"`
}

// The set of arguments for constructing a AppsValidateAppSpec resource.
type AppsValidateAppSpecArgs struct {
	// An optional ID of an existing app. If set, the spec will be treated as a proposed update to the specified app. The existing app is not modified using this method.
	AppId pulumi.StringPtrInput
	// The desired configuration of an application.
	Spec AppSpecInput
}

func (AppsValidateAppSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*appsValidateAppSpecArgs)(nil)).Elem()
}

type AppsValidateAppSpecInput interface {
	pulumi.Input

	ToAppsValidateAppSpecOutput() AppsValidateAppSpecOutput
	ToAppsValidateAppSpecOutputWithContext(ctx context.Context) AppsValidateAppSpecOutput
}

func (*AppsValidateAppSpec) ElementType() reflect.Type {
	return reflect.TypeOf((**AppsValidateAppSpec)(nil)).Elem()
}

func (i *AppsValidateAppSpec) ToAppsValidateAppSpecOutput() AppsValidateAppSpecOutput {
	return i.ToAppsValidateAppSpecOutputWithContext(context.Background())
}

func (i *AppsValidateAppSpec) ToAppsValidateAppSpecOutputWithContext(ctx context.Context) AppsValidateAppSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppsValidateAppSpecOutput)
}

type AppsValidateAppSpecOutput struct{ *pulumi.OutputState }

func (AppsValidateAppSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppsValidateAppSpec)(nil)).Elem()
}

func (o AppsValidateAppSpecOutput) ToAppsValidateAppSpecOutput() AppsValidateAppSpecOutput {
	return o
}

func (o AppsValidateAppSpecOutput) ToAppsValidateAppSpecOutputWithContext(ctx context.Context) AppsValidateAppSpecOutput {
	return o
}

// The monthly cost of the proposed app in USD using the next pricing plan tier. For example, if you propose an app that uses the Basic tier, the `app_tier_upgrade_cost` field displays the monthly cost of the app if it were to use the Professional tier. If the proposed app already uses the most expensive tier, the field is empty.
func (o AppsValidateAppSpecOutput) AppCost() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.IntPtrOutput { return v.AppCost }).(pulumi.IntPtrOutput)
}

// An optional ID of an existing app. If set, the spec will be treated as a proposed update to the specified app. The existing app is not modified using this method.
func (o AppsValidateAppSpecOutput) AppId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.StringPtrOutput { return v.AppId }).(pulumi.StringPtrOutput)
}

// Indicates whether the app is a static app.
func (o AppsValidateAppSpecOutput) AppIsStatic() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.BoolPtrOutput { return v.AppIsStatic }).(pulumi.BoolPtrOutput)
}

// Indicates whether the app name is available.
func (o AppsValidateAppSpecOutput) AppNameAvailable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.BoolPtrOutput { return v.AppNameAvailable }).(pulumi.BoolPtrOutput)
}

// The suggested name if the proposed app name is unavailable.
func (o AppsValidateAppSpecOutput) AppNameSuggestion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.StringPtrOutput { return v.AppNameSuggestion }).(pulumi.StringPtrOutput)
}

// The monthly cost of the proposed app in USD using the previous pricing plan tier. For example, if you propose an app that uses the Professional tier, the `app_tier_downgrade_cost` field displays the monthly cost of the app if it were to use the Basic tier. If the proposed app already uses the lest expensive tier, the field is empty.
func (o AppsValidateAppSpecOutput) AppTierDowngradeCost() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.IntPtrOutput { return v.AppTierDowngradeCost }).(pulumi.IntPtrOutput)
}

// The maximum number of free static apps the account can have. We will charge you for any additional static apps.
func (o AppsValidateAppSpecOutput) ExistingStaticApps() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) pulumi.StringPtrOutput { return v.ExistingStaticApps }).(pulumi.StringPtrOutput)
}

// The desired configuration of an application.
func (o AppsValidateAppSpecOutput) Spec() AppSpecOutput {
	return o.ApplyT(func(v *AppsValidateAppSpec) AppSpecOutput { return v.Spec }).(AppSpecOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AppsValidateAppSpecInput)(nil)).Elem(), &AppsValidateAppSpec{})
	pulumi.RegisterOutputType(AppsValidateAppSpecOutput{})
}
