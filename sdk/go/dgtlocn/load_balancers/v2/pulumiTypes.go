// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"context"
	"reflect"

	"github.com/cloudy-sky-software/pulumi-digitalocean-native/sdk/go/dgtlocn/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// An object specifying a forwarding rule for a load balancer.
type ForwardingRule struct {
	// The ID of the TLS certificate used for SSL termination if enabled.
	CertificateId *string `pulumi:"certificateId"`
	// An integer representing the port on which the load balancer instance will listen.
	EntryPort int `pulumi:"entryPort"`
	// The protocol used for traffic to the load balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`. If you set the  `entry_protocol` to `udp`, the `target_protocol` must be set to `udp`.  When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
	EntryProtocol ForwardingRuleEntryProtocol `pulumi:"entryProtocol"`
	// An integer representing the port on the backend Droplets to which the load balancer will send traffic.
	TargetPort int `pulumi:"targetPort"`
	// The protocol used for traffic from the load balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`. If you set the `target_protocol` to `udp`, the `entry_protocol` must be set to  `udp`. When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
	TargetProtocol ForwardingRuleTargetProtocol `pulumi:"targetProtocol"`
	// A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets.
	TlsPassthrough *bool `pulumi:"tlsPassthrough"`
}

// ForwardingRuleInput is an input type that accepts ForwardingRuleArgs and ForwardingRuleOutput values.
// You can construct a concrete instance of `ForwardingRuleInput` via:
//
//	ForwardingRuleArgs{...}
type ForwardingRuleInput interface {
	pulumi.Input

	ToForwardingRuleOutput() ForwardingRuleOutput
	ToForwardingRuleOutputWithContext(context.Context) ForwardingRuleOutput
}

// An object specifying a forwarding rule for a load balancer.
type ForwardingRuleArgs struct {
	// The ID of the TLS certificate used for SSL termination if enabled.
	CertificateId pulumi.StringPtrInput `pulumi:"certificateId"`
	// An integer representing the port on which the load balancer instance will listen.
	EntryPort pulumi.IntInput `pulumi:"entryPort"`
	// The protocol used for traffic to the load balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`. If you set the  `entry_protocol` to `udp`, the `target_protocol` must be set to `udp`.  When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
	EntryProtocol ForwardingRuleEntryProtocolInput `pulumi:"entryProtocol"`
	// An integer representing the port on the backend Droplets to which the load balancer will send traffic.
	TargetPort pulumi.IntInput `pulumi:"targetPort"`
	// The protocol used for traffic from the load balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`. If you set the `target_protocol` to `udp`, the `entry_protocol` must be set to  `udp`. When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
	TargetProtocol ForwardingRuleTargetProtocolInput `pulumi:"targetProtocol"`
	// A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets.
	TlsPassthrough pulumi.BoolPtrInput `pulumi:"tlsPassthrough"`
}

func (ForwardingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ForwardingRule)(nil)).Elem()
}

func (i ForwardingRuleArgs) ToForwardingRuleOutput() ForwardingRuleOutput {
	return i.ToForwardingRuleOutputWithContext(context.Background())
}

func (i ForwardingRuleArgs) ToForwardingRuleOutputWithContext(ctx context.Context) ForwardingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ForwardingRuleOutput)
}

// ForwardingRuleArrayInput is an input type that accepts ForwardingRuleArray and ForwardingRuleArrayOutput values.
// You can construct a concrete instance of `ForwardingRuleArrayInput` via:
//
//	ForwardingRuleArray{ ForwardingRuleArgs{...} }
type ForwardingRuleArrayInput interface {
	pulumi.Input

	ToForwardingRuleArrayOutput() ForwardingRuleArrayOutput
	ToForwardingRuleArrayOutputWithContext(context.Context) ForwardingRuleArrayOutput
}

type ForwardingRuleArray []ForwardingRuleInput

func (ForwardingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ForwardingRule)(nil)).Elem()
}

func (i ForwardingRuleArray) ToForwardingRuleArrayOutput() ForwardingRuleArrayOutput {
	return i.ToForwardingRuleArrayOutputWithContext(context.Background())
}

func (i ForwardingRuleArray) ToForwardingRuleArrayOutputWithContext(ctx context.Context) ForwardingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ForwardingRuleArrayOutput)
}

// An object specifying a forwarding rule for a load balancer.
type ForwardingRuleOutput struct{ *pulumi.OutputState }

func (ForwardingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ForwardingRule)(nil)).Elem()
}

func (o ForwardingRuleOutput) ToForwardingRuleOutput() ForwardingRuleOutput {
	return o
}

func (o ForwardingRuleOutput) ToForwardingRuleOutputWithContext(ctx context.Context) ForwardingRuleOutput {
	return o
}

// The ID of the TLS certificate used for SSL termination if enabled.
func (o ForwardingRuleOutput) CertificateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ForwardingRule) *string { return v.CertificateId }).(pulumi.StringPtrOutput)
}

// An integer representing the port on which the load balancer instance will listen.
func (o ForwardingRuleOutput) EntryPort() pulumi.IntOutput {
	return o.ApplyT(func(v ForwardingRule) int { return v.EntryPort }).(pulumi.IntOutput)
}

// The protocol used for traffic to the load balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`. If you set the  `entry_protocol` to `udp`, the `target_protocol` must be set to `udp`.  When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
func (o ForwardingRuleOutput) EntryProtocol() ForwardingRuleEntryProtocolOutput {
	return o.ApplyT(func(v ForwardingRule) ForwardingRuleEntryProtocol { return v.EntryProtocol }).(ForwardingRuleEntryProtocolOutput)
}

// An integer representing the port on the backend Droplets to which the load balancer will send traffic.
func (o ForwardingRuleOutput) TargetPort() pulumi.IntOutput {
	return o.ApplyT(func(v ForwardingRule) int { return v.TargetPort }).(pulumi.IntOutput)
}

// The protocol used for traffic from the load balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`. If you set the `target_protocol` to `udp`, the `entry_protocol` must be set to  `udp`. When using UDP, the load balancer requires that you set up a health  check with a port that uses TCP, HTTP, or HTTPS to work properly.
func (o ForwardingRuleOutput) TargetProtocol() ForwardingRuleTargetProtocolOutput {
	return o.ApplyT(func(v ForwardingRule) ForwardingRuleTargetProtocol { return v.TargetProtocol }).(ForwardingRuleTargetProtocolOutput)
}

// A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets.
func (o ForwardingRuleOutput) TlsPassthrough() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ForwardingRule) *bool { return v.TlsPassthrough }).(pulumi.BoolPtrOutput)
}

type ForwardingRuleArrayOutput struct{ *pulumi.OutputState }

func (ForwardingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ForwardingRule)(nil)).Elem()
}

func (o ForwardingRuleArrayOutput) ToForwardingRuleArrayOutput() ForwardingRuleArrayOutput {
	return o
}

func (o ForwardingRuleArrayOutput) ToForwardingRuleArrayOutputWithContext(ctx context.Context) ForwardingRuleArrayOutput {
	return o
}

func (o ForwardingRuleArrayOutput) Index(i pulumi.IntInput) ForwardingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ForwardingRule {
		return vs[0].([]ForwardingRule)[vs[1].(int)]
	}).(ForwardingRuleOutput)
}

type GetLoadBalancerProperties struct {
	LoadBalancer *LoadBalancerType `pulumi:"loadBalancer"`
}

// Defaults sets the appropriate defaults for GetLoadBalancerProperties
func (val *GetLoadBalancerProperties) Defaults() *GetLoadBalancerProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LoadBalancer = tmp.LoadBalancer.Defaults()

	return &tmp
}

type GetLoadBalancerPropertiesOutput struct{ *pulumi.OutputState }

func (GetLoadBalancerPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetLoadBalancerProperties)(nil)).Elem()
}

func (o GetLoadBalancerPropertiesOutput) ToGetLoadBalancerPropertiesOutput() GetLoadBalancerPropertiesOutput {
	return o
}

func (o GetLoadBalancerPropertiesOutput) ToGetLoadBalancerPropertiesOutputWithContext(ctx context.Context) GetLoadBalancerPropertiesOutput {
	return o
}

func (o GetLoadBalancerPropertiesOutput) LoadBalancer() LoadBalancerTypePtrOutput {
	return o.ApplyT(func(v GetLoadBalancerProperties) *LoadBalancerType { return v.LoadBalancer }).(LoadBalancerTypePtrOutput)
}

// An object specifying health check settings for the load balancer.
type HealthCheck struct {
	// The number of seconds between between two consecutive health checks.
	CheckIntervalSeconds *int `pulumi:"checkIntervalSeconds"`
	// The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool.
	HealthyThreshold *int `pulumi:"healthyThreshold"`
	// The path on the backend Droplets to which the load balancer instance will send a request.
	Path *string `pulumi:"path"`
	// An integer representing the port on the backend Droplets on which the health check will attempt a connection.
	Port *int `pulumi:"port"`
	// The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.
	Protocol *HealthCheckProtocol `pulumi:"protocol"`
	// The number of seconds the load balancer instance will wait for a response until marking a health check as failed.
	ResponseTimeoutSeconds *int `pulumi:"responseTimeoutSeconds"`
	// The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool.
	UnhealthyThreshold *int `pulumi:"unhealthyThreshold"`
}

// Defaults sets the appropriate defaults for HealthCheck
func (val *HealthCheck) Defaults() *HealthCheck {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.CheckIntervalSeconds == nil {
		checkIntervalSeconds_ := 10
		tmp.CheckIntervalSeconds = &checkIntervalSeconds_
	}
	if tmp.HealthyThreshold == nil {
		healthyThreshold_ := 3
		tmp.HealthyThreshold = &healthyThreshold_
	}
	if tmp.Path == nil {
		path_ := "/"
		tmp.Path = &path_
	}
	if tmp.Port == nil {
		port_ := 80
		tmp.Port = &port_
	}
	if tmp.Protocol == nil {
		protocol_ := HealthCheckProtocol("http")
		tmp.Protocol = &protocol_
	}
	if tmp.ResponseTimeoutSeconds == nil {
		responseTimeoutSeconds_ := 5
		tmp.ResponseTimeoutSeconds = &responseTimeoutSeconds_
	}
	if tmp.UnhealthyThreshold == nil {
		unhealthyThreshold_ := 5
		tmp.UnhealthyThreshold = &unhealthyThreshold_
	}
	return &tmp
}

// HealthCheckInput is an input type that accepts HealthCheckArgs and HealthCheckOutput values.
// You can construct a concrete instance of `HealthCheckInput` via:
//
//	HealthCheckArgs{...}
type HealthCheckInput interface {
	pulumi.Input

	ToHealthCheckOutput() HealthCheckOutput
	ToHealthCheckOutputWithContext(context.Context) HealthCheckOutput
}

// An object specifying health check settings for the load balancer.
type HealthCheckArgs struct {
	// The number of seconds between between two consecutive health checks.
	CheckIntervalSeconds pulumi.IntPtrInput `pulumi:"checkIntervalSeconds"`
	// The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool.
	HealthyThreshold pulumi.IntPtrInput `pulumi:"healthyThreshold"`
	// The path on the backend Droplets to which the load balancer instance will send a request.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// An integer representing the port on the backend Droplets on which the health check will attempt a connection.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.
	Protocol HealthCheckProtocolPtrInput `pulumi:"protocol"`
	// The number of seconds the load balancer instance will wait for a response until marking a health check as failed.
	ResponseTimeoutSeconds pulumi.IntPtrInput `pulumi:"responseTimeoutSeconds"`
	// The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool.
	UnhealthyThreshold pulumi.IntPtrInput `pulumi:"unhealthyThreshold"`
}

// Defaults sets the appropriate defaults for HealthCheckArgs
func (val *HealthCheckArgs) Defaults() *HealthCheckArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.CheckIntervalSeconds == nil {
		tmp.CheckIntervalSeconds = pulumi.IntPtr(10)
	}
	if tmp.HealthyThreshold == nil {
		tmp.HealthyThreshold = pulumi.IntPtr(3)
	}
	if tmp.Path == nil {
		tmp.Path = pulumi.StringPtr("/")
	}
	if tmp.Port == nil {
		tmp.Port = pulumi.IntPtr(80)
	}
	if tmp.Protocol == nil {
		tmp.Protocol = HealthCheckProtocol("http")
	}
	if tmp.ResponseTimeoutSeconds == nil {
		tmp.ResponseTimeoutSeconds = pulumi.IntPtr(5)
	}
	if tmp.UnhealthyThreshold == nil {
		tmp.UnhealthyThreshold = pulumi.IntPtr(5)
	}
	return &tmp
}
func (HealthCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HealthCheck)(nil)).Elem()
}

func (i HealthCheckArgs) ToHealthCheckOutput() HealthCheckOutput {
	return i.ToHealthCheckOutputWithContext(context.Background())
}

func (i HealthCheckArgs) ToHealthCheckOutputWithContext(ctx context.Context) HealthCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckOutput)
}

func (i HealthCheckArgs) ToHealthCheckPtrOutput() HealthCheckPtrOutput {
	return i.ToHealthCheckPtrOutputWithContext(context.Background())
}

func (i HealthCheckArgs) ToHealthCheckPtrOutputWithContext(ctx context.Context) HealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckOutput).ToHealthCheckPtrOutputWithContext(ctx)
}

// HealthCheckPtrInput is an input type that accepts HealthCheckArgs, HealthCheckPtr and HealthCheckPtrOutput values.
// You can construct a concrete instance of `HealthCheckPtrInput` via:
//
//	        HealthCheckArgs{...}
//
//	or:
//
//	        nil
type HealthCheckPtrInput interface {
	pulumi.Input

	ToHealthCheckPtrOutput() HealthCheckPtrOutput
	ToHealthCheckPtrOutputWithContext(context.Context) HealthCheckPtrOutput
}

type healthCheckPtrType HealthCheckArgs

func HealthCheckPtr(v *HealthCheckArgs) HealthCheckPtrInput {
	return (*healthCheckPtrType)(v)
}

func (*healthCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HealthCheck)(nil)).Elem()
}

func (i *healthCheckPtrType) ToHealthCheckPtrOutput() HealthCheckPtrOutput {
	return i.ToHealthCheckPtrOutputWithContext(context.Background())
}

func (i *healthCheckPtrType) ToHealthCheckPtrOutputWithContext(ctx context.Context) HealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckPtrOutput)
}

// An object specifying health check settings for the load balancer.
type HealthCheckOutput struct{ *pulumi.OutputState }

func (HealthCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HealthCheck)(nil)).Elem()
}

func (o HealthCheckOutput) ToHealthCheckOutput() HealthCheckOutput {
	return o
}

func (o HealthCheckOutput) ToHealthCheckOutputWithContext(ctx context.Context) HealthCheckOutput {
	return o
}

func (o HealthCheckOutput) ToHealthCheckPtrOutput() HealthCheckPtrOutput {
	return o.ToHealthCheckPtrOutputWithContext(context.Background())
}

func (o HealthCheckOutput) ToHealthCheckPtrOutputWithContext(ctx context.Context) HealthCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HealthCheck) *HealthCheck {
		return &v
	}).(HealthCheckPtrOutput)
}

// The number of seconds between between two consecutive health checks.
func (o HealthCheckOutput) CheckIntervalSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheck) *int { return v.CheckIntervalSeconds }).(pulumi.IntPtrOutput)
}

// The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool.
func (o HealthCheckOutput) HealthyThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheck) *int { return v.HealthyThreshold }).(pulumi.IntPtrOutput)
}

// The path on the backend Droplets to which the load balancer instance will send a request.
func (o HealthCheckOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HealthCheck) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// An integer representing the port on the backend Droplets on which the health check will attempt a connection.
func (o HealthCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.
func (o HealthCheckOutput) Protocol() HealthCheckProtocolPtrOutput {
	return o.ApplyT(func(v HealthCheck) *HealthCheckProtocol { return v.Protocol }).(HealthCheckProtocolPtrOutput)
}

// The number of seconds the load balancer instance will wait for a response until marking a health check as failed.
func (o HealthCheckOutput) ResponseTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheck) *int { return v.ResponseTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool.
func (o HealthCheckOutput) UnhealthyThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheck) *int { return v.UnhealthyThreshold }).(pulumi.IntPtrOutput)
}

type HealthCheckPtrOutput struct{ *pulumi.OutputState }

func (HealthCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HealthCheck)(nil)).Elem()
}

func (o HealthCheckPtrOutput) ToHealthCheckPtrOutput() HealthCheckPtrOutput {
	return o
}

func (o HealthCheckPtrOutput) ToHealthCheckPtrOutputWithContext(ctx context.Context) HealthCheckPtrOutput {
	return o
}

func (o HealthCheckPtrOutput) Elem() HealthCheckOutput {
	return o.ApplyT(func(v *HealthCheck) HealthCheck {
		if v != nil {
			return *v
		}
		var ret HealthCheck
		return ret
	}).(HealthCheckOutput)
}

// The number of seconds between between two consecutive health checks.
func (o HealthCheckPtrOutput) CheckIntervalSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.CheckIntervalSeconds
	}).(pulumi.IntPtrOutput)
}

// The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool.
func (o HealthCheckPtrOutput) HealthyThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.HealthyThreshold
	}).(pulumi.IntPtrOutput)
}

// The path on the backend Droplets to which the load balancer instance will send a request.
func (o HealthCheckPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// An integer representing the port on the backend Droplets on which the health check will attempt a connection.
func (o HealthCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https`, or `tcp`.
func (o HealthCheckPtrOutput) Protocol() HealthCheckProtocolPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *HealthCheckProtocol {
		if v == nil {
			return nil
		}
		return v.Protocol
	}).(HealthCheckProtocolPtrOutput)
}

// The number of seconds the load balancer instance will wait for a response until marking a health check as failed.
func (o HealthCheckPtrOutput) ResponseTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.ResponseTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool.
func (o HealthCheckPtrOutput) UnhealthyThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.UnhealthyThreshold
	}).(pulumi.IntPtrOutput)
}

// An object specifying allow and deny rules to control traffic to the load balancer.
type LbFirewall struct {
	// the rules for allowing traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
	Allow []string `pulumi:"allow"`
	// the rules for denying traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
	Deny []string `pulumi:"deny"`
}

// LbFirewallInput is an input type that accepts LbFirewallArgs and LbFirewallOutput values.
// You can construct a concrete instance of `LbFirewallInput` via:
//
//	LbFirewallArgs{...}
type LbFirewallInput interface {
	pulumi.Input

	ToLbFirewallOutput() LbFirewallOutput
	ToLbFirewallOutputWithContext(context.Context) LbFirewallOutput
}

// An object specifying allow and deny rules to control traffic to the load balancer.
type LbFirewallArgs struct {
	// the rules for allowing traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
	Allow pulumi.StringArrayInput `pulumi:"allow"`
	// the rules for denying traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
	Deny pulumi.StringArrayInput `pulumi:"deny"`
}

func (LbFirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LbFirewall)(nil)).Elem()
}

func (i LbFirewallArgs) ToLbFirewallOutput() LbFirewallOutput {
	return i.ToLbFirewallOutputWithContext(context.Background())
}

func (i LbFirewallArgs) ToLbFirewallOutputWithContext(ctx context.Context) LbFirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LbFirewallOutput)
}

func (i LbFirewallArgs) ToLbFirewallPtrOutput() LbFirewallPtrOutput {
	return i.ToLbFirewallPtrOutputWithContext(context.Background())
}

func (i LbFirewallArgs) ToLbFirewallPtrOutputWithContext(ctx context.Context) LbFirewallPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LbFirewallOutput).ToLbFirewallPtrOutputWithContext(ctx)
}

// LbFirewallPtrInput is an input type that accepts LbFirewallArgs, LbFirewallPtr and LbFirewallPtrOutput values.
// You can construct a concrete instance of `LbFirewallPtrInput` via:
//
//	        LbFirewallArgs{...}
//
//	or:
//
//	        nil
type LbFirewallPtrInput interface {
	pulumi.Input

	ToLbFirewallPtrOutput() LbFirewallPtrOutput
	ToLbFirewallPtrOutputWithContext(context.Context) LbFirewallPtrOutput
}

type lbFirewallPtrType LbFirewallArgs

func LbFirewallPtr(v *LbFirewallArgs) LbFirewallPtrInput {
	return (*lbFirewallPtrType)(v)
}

func (*lbFirewallPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LbFirewall)(nil)).Elem()
}

func (i *lbFirewallPtrType) ToLbFirewallPtrOutput() LbFirewallPtrOutput {
	return i.ToLbFirewallPtrOutputWithContext(context.Background())
}

func (i *lbFirewallPtrType) ToLbFirewallPtrOutputWithContext(ctx context.Context) LbFirewallPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LbFirewallPtrOutput)
}

// An object specifying allow and deny rules to control traffic to the load balancer.
type LbFirewallOutput struct{ *pulumi.OutputState }

func (LbFirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LbFirewall)(nil)).Elem()
}

func (o LbFirewallOutput) ToLbFirewallOutput() LbFirewallOutput {
	return o
}

func (o LbFirewallOutput) ToLbFirewallOutputWithContext(ctx context.Context) LbFirewallOutput {
	return o
}

func (o LbFirewallOutput) ToLbFirewallPtrOutput() LbFirewallPtrOutput {
	return o.ToLbFirewallPtrOutputWithContext(context.Background())
}

func (o LbFirewallOutput) ToLbFirewallPtrOutputWithContext(ctx context.Context) LbFirewallPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LbFirewall) *LbFirewall {
		return &v
	}).(LbFirewallPtrOutput)
}

// the rules for allowing traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
func (o LbFirewallOutput) Allow() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LbFirewall) []string { return v.Allow }).(pulumi.StringArrayOutput)
}

// the rules for denying traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
func (o LbFirewallOutput) Deny() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LbFirewall) []string { return v.Deny }).(pulumi.StringArrayOutput)
}

type LbFirewallPtrOutput struct{ *pulumi.OutputState }

func (LbFirewallPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LbFirewall)(nil)).Elem()
}

func (o LbFirewallPtrOutput) ToLbFirewallPtrOutput() LbFirewallPtrOutput {
	return o
}

func (o LbFirewallPtrOutput) ToLbFirewallPtrOutputWithContext(ctx context.Context) LbFirewallPtrOutput {
	return o
}

func (o LbFirewallPtrOutput) Elem() LbFirewallOutput {
	return o.ApplyT(func(v *LbFirewall) LbFirewall {
		if v != nil {
			return *v
		}
		var ret LbFirewall
		return ret
	}).(LbFirewallOutput)
}

// the rules for allowing traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
func (o LbFirewallPtrOutput) Allow() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LbFirewall) []string {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(pulumi.StringArrayOutput)
}

// the rules for denying traffic to the load balancer (in the form 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
func (o LbFirewallPtrOutput) Deny() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LbFirewall) []string {
		if v == nil {
			return nil
		}
		return v.Deny
	}).(pulumi.StringArrayOutput)
}

type ListLoadBalancersItems struct {
	Links         *PageLinks         `pulumi:"links"`
	LoadBalancers []LoadBalancerType `pulumi:"loadBalancers"`
	Meta          MetaMeta           `pulumi:"meta"`
}

type ListLoadBalancersItemsOutput struct{ *pulumi.OutputState }

func (ListLoadBalancersItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ListLoadBalancersItems)(nil)).Elem()
}

func (o ListLoadBalancersItemsOutput) ToListLoadBalancersItemsOutput() ListLoadBalancersItemsOutput {
	return o
}

func (o ListLoadBalancersItemsOutput) ToListLoadBalancersItemsOutputWithContext(ctx context.Context) ListLoadBalancersItemsOutput {
	return o
}

func (o ListLoadBalancersItemsOutput) Links() PageLinksPtrOutput {
	return o.ApplyT(func(v ListLoadBalancersItems) *PageLinks { return v.Links }).(PageLinksPtrOutput)
}

func (o ListLoadBalancersItemsOutput) LoadBalancers() LoadBalancerTypeArrayOutput {
	return o.ApplyT(func(v ListLoadBalancersItems) []LoadBalancerType { return v.LoadBalancers }).(LoadBalancerTypeArrayOutput)
}

func (o ListLoadBalancersItemsOutput) Meta() MetaMetaOutput {
	return o.ApplyT(func(v ListLoadBalancersItems) MetaMeta { return v.Meta }).(MetaMetaOutput)
}

type LoadBalancerType struct {
	// This field has been deprecated. You can no longer specify an algorithm for load balancers.
	Algorithm *LoadBalancerBaseAlgorithm `pulumi:"algorithm"`
	// A time value given in ISO8601 combined date and time format that represents when the load balancer was created.
	CreatedAt *string `pulumi:"createdAt"`
	// A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer.
	DisableLetsEncryptDnsRecords *bool `pulumi:"disableLetsEncryptDnsRecords"`
	// A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.
	EnableBackendKeepalive *bool `pulumi:"enableBackendKeepalive"`
	// A boolean value indicating whether PROXY Protocol is in use.
	EnableProxyProtocol *bool `pulumi:"enableProxyProtocol"`
	// An object specifying allow and deny rules to control traffic to the load balancer.
	Firewall *LbFirewall `pulumi:"firewall"`
	// An array of objects specifying the forwarding rules for a load balancer.
	ForwardingRules []ForwardingRule `pulumi:"forwardingRules"`
	// An object specifying health check settings for the load balancer.
	HealthCheck *HealthCheck `pulumi:"healthCheck"`
	// An integer value which configures the idle timeout for HTTP requests to the target droplets.
	HttpIdleTimeoutSeconds *int `pulumi:"httpIdleTimeoutSeconds"`
	// A unique ID that can be used to identify and reference a load balancer.
	Id *string `pulumi:"id"`
	// An attribute containing the public-facing IP address of the load balancer.
	Ip *string `pulumi:"ip"`
	// A human-readable name for a load balancer instance.
	Name *string `pulumi:"name"`
	// The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project. If an invalid project ID is provided, the load balancer will not be created.
	ProjectId *string `pulumi:"projectId"`
	// A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.
	RedirectHttpToHttps *bool `pulumi:"redirectHttpToHttps"`
	// This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes.
	// * `lb-small` = 1 node
	// * `lb-medium` = 3 nodes
	// * `lb-large` = 6 nodes
	//
	// You can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.
	Size *LoadBalancerBaseSize `pulumi:"size"`
	// How many nodes the load balancer contains. Each additional node increases the load balancer's ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.
	SizeUnit *int `pulumi:"sizeUnit"`
	// A status string indicating the current state of the load balancer. This can be `new`, `active`, or `errored`.
	Status *LoadBalancerBaseStatus `pulumi:"status"`
	// An object specifying sticky sessions settings for the load balancer.
	StickySessions *StickySessions `pulumi:"stickySessions"`
	// The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
	Tag *string `pulumi:"tag"`
	// A string specifying the UUID of the VPC to which the load balancer is assigned.
	VpcUuid *string `pulumi:"vpcUuid"`
}

// Defaults sets the appropriate defaults for LoadBalancerType
func (val *LoadBalancerType) Defaults() *LoadBalancerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Algorithm == nil {
		algorithm_ := LoadBalancerBaseAlgorithm("round_robin")
		tmp.Algorithm = &algorithm_
	}
	if tmp.DisableLetsEncryptDnsRecords == nil {
		disableLetsEncryptDnsRecords_ := false
		tmp.DisableLetsEncryptDnsRecords = &disableLetsEncryptDnsRecords_
	}
	if tmp.EnableBackendKeepalive == nil {
		enableBackendKeepalive_ := false
		tmp.EnableBackendKeepalive = &enableBackendKeepalive_
	}
	if tmp.EnableProxyProtocol == nil {
		enableProxyProtocol_ := false
		tmp.EnableProxyProtocol = &enableProxyProtocol_
	}
	tmp.HealthCheck = tmp.HealthCheck.Defaults()

	if tmp.HttpIdleTimeoutSeconds == nil {
		httpIdleTimeoutSeconds_ := 60
		tmp.HttpIdleTimeoutSeconds = &httpIdleTimeoutSeconds_
	}
	if tmp.RedirectHttpToHttps == nil {
		redirectHttpToHttps_ := false
		tmp.RedirectHttpToHttps = &redirectHttpToHttps_
	}
	if tmp.Size == nil {
		size_ := LoadBalancerBaseSize("lb-small")
		tmp.Size = &size_
	}
	if tmp.SizeUnit == nil {
		sizeUnit_ := 1
		tmp.SizeUnit = &sizeUnit_
	}
	tmp.StickySessions = tmp.StickySessions.Defaults()

	return &tmp
}

type LoadBalancerTypeOutput struct{ *pulumi.OutputState }

func (LoadBalancerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancerType)(nil)).Elem()
}

func (o LoadBalancerTypeOutput) ToLoadBalancerTypeOutput() LoadBalancerTypeOutput {
	return o
}

func (o LoadBalancerTypeOutput) ToLoadBalancerTypeOutputWithContext(ctx context.Context) LoadBalancerTypeOutput {
	return o
}

// This field has been deprecated. You can no longer specify an algorithm for load balancers.
func (o LoadBalancerTypeOutput) Algorithm() LoadBalancerBaseAlgorithmPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *LoadBalancerBaseAlgorithm { return v.Algorithm }).(LoadBalancerBaseAlgorithmPtrOutput)
}

// A time value given in ISO8601 combined date and time format that represents when the load balancer was created.
func (o LoadBalancerTypeOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer.
func (o LoadBalancerTypeOutput) DisableLetsEncryptDnsRecords() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *bool { return v.DisableLetsEncryptDnsRecords }).(pulumi.BoolPtrOutput)
}

// A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.
func (o LoadBalancerTypeOutput) EnableBackendKeepalive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *bool { return v.EnableBackendKeepalive }).(pulumi.BoolPtrOutput)
}

// A boolean value indicating whether PROXY Protocol is in use.
func (o LoadBalancerTypeOutput) EnableProxyProtocol() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *bool { return v.EnableProxyProtocol }).(pulumi.BoolPtrOutput)
}

// An object specifying allow and deny rules to control traffic to the load balancer.
func (o LoadBalancerTypeOutput) Firewall() LbFirewallPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *LbFirewall { return v.Firewall }).(LbFirewallPtrOutput)
}

// An array of objects specifying the forwarding rules for a load balancer.
func (o LoadBalancerTypeOutput) ForwardingRules() ForwardingRuleArrayOutput {
	return o.ApplyT(func(v LoadBalancerType) []ForwardingRule { return v.ForwardingRules }).(ForwardingRuleArrayOutput)
}

// An object specifying health check settings for the load balancer.
func (o LoadBalancerTypeOutput) HealthCheck() HealthCheckPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *HealthCheck { return v.HealthCheck }).(HealthCheckPtrOutput)
}

// An integer value which configures the idle timeout for HTTP requests to the target droplets.
func (o LoadBalancerTypeOutput) HttpIdleTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *int { return v.HttpIdleTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// A unique ID that can be used to identify and reference a load balancer.
func (o LoadBalancerTypeOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// An attribute containing the public-facing IP address of the load balancer.
func (o LoadBalancerTypeOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

// A human-readable name for a load balancer instance.
func (o LoadBalancerTypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project. If an invalid project ID is provided, the load balancer will not be created.
func (o LoadBalancerTypeOutput) ProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.ProjectId }).(pulumi.StringPtrOutput)
}

// A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.
func (o LoadBalancerTypeOutput) RedirectHttpToHttps() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *bool { return v.RedirectHttpToHttps }).(pulumi.BoolPtrOutput)
}

// This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes.
// * `lb-small` = 1 node
// * `lb-medium` = 3 nodes
// * `lb-large` = 6 nodes
//
// You can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.
func (o LoadBalancerTypeOutput) Size() LoadBalancerBaseSizePtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *LoadBalancerBaseSize { return v.Size }).(LoadBalancerBaseSizePtrOutput)
}

// How many nodes the load balancer contains. Each additional node increases the load balancer's ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.
func (o LoadBalancerTypeOutput) SizeUnit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *int { return v.SizeUnit }).(pulumi.IntPtrOutput)
}

// A status string indicating the current state of the load balancer. This can be `new`, `active`, or `errored`.
func (o LoadBalancerTypeOutput) Status() LoadBalancerBaseStatusPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *LoadBalancerBaseStatus { return v.Status }).(LoadBalancerBaseStatusPtrOutput)
}

// An object specifying sticky sessions settings for the load balancer.
func (o LoadBalancerTypeOutput) StickySessions() StickySessionsPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *StickySessions { return v.StickySessions }).(StickySessionsPtrOutput)
}

// The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
func (o LoadBalancerTypeOutput) Tag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.Tag }).(pulumi.StringPtrOutput)
}

// A string specifying the UUID of the VPC to which the load balancer is assigned.
func (o LoadBalancerTypeOutput) VpcUuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancerType) *string { return v.VpcUuid }).(pulumi.StringPtrOutput)
}

type LoadBalancerTypePtrOutput struct{ *pulumi.OutputState }

func (LoadBalancerTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoadBalancerType)(nil)).Elem()
}

func (o LoadBalancerTypePtrOutput) ToLoadBalancerTypePtrOutput() LoadBalancerTypePtrOutput {
	return o
}

func (o LoadBalancerTypePtrOutput) ToLoadBalancerTypePtrOutputWithContext(ctx context.Context) LoadBalancerTypePtrOutput {
	return o
}

func (o LoadBalancerTypePtrOutput) Elem() LoadBalancerTypeOutput {
	return o.ApplyT(func(v *LoadBalancerType) LoadBalancerType {
		if v != nil {
			return *v
		}
		var ret LoadBalancerType
		return ret
	}).(LoadBalancerTypeOutput)
}

// This field has been deprecated. You can no longer specify an algorithm for load balancers.
func (o LoadBalancerTypePtrOutput) Algorithm() LoadBalancerBaseAlgorithmPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *LoadBalancerBaseAlgorithm {
		if v == nil {
			return nil
		}
		return v.Algorithm
	}).(LoadBalancerBaseAlgorithmPtrOutput)
}

// A time value given in ISO8601 combined date and time format that represents when the load balancer was created.
func (o LoadBalancerTypePtrOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.CreatedAt
	}).(pulumi.StringPtrOutput)
}

// A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer.
func (o LoadBalancerTypePtrOutput) DisableLetsEncryptDnsRecords() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *bool {
		if v == nil {
			return nil
		}
		return v.DisableLetsEncryptDnsRecords
	}).(pulumi.BoolPtrOutput)
}

// A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.
func (o LoadBalancerTypePtrOutput) EnableBackendKeepalive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *bool {
		if v == nil {
			return nil
		}
		return v.EnableBackendKeepalive
	}).(pulumi.BoolPtrOutput)
}

// A boolean value indicating whether PROXY Protocol is in use.
func (o LoadBalancerTypePtrOutput) EnableProxyProtocol() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *bool {
		if v == nil {
			return nil
		}
		return v.EnableProxyProtocol
	}).(pulumi.BoolPtrOutput)
}

// An object specifying allow and deny rules to control traffic to the load balancer.
func (o LoadBalancerTypePtrOutput) Firewall() LbFirewallPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *LbFirewall {
		if v == nil {
			return nil
		}
		return v.Firewall
	}).(LbFirewallPtrOutput)
}

// An array of objects specifying the forwarding rules for a load balancer.
func (o LoadBalancerTypePtrOutput) ForwardingRules() ForwardingRuleArrayOutput {
	return o.ApplyT(func(v *LoadBalancerType) []ForwardingRule {
		if v == nil {
			return nil
		}
		return v.ForwardingRules
	}).(ForwardingRuleArrayOutput)
}

// An object specifying health check settings for the load balancer.
func (o LoadBalancerTypePtrOutput) HealthCheck() HealthCheckPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *HealthCheck {
		if v == nil {
			return nil
		}
		return v.HealthCheck
	}).(HealthCheckPtrOutput)
}

// An integer value which configures the idle timeout for HTTP requests to the target droplets.
func (o LoadBalancerTypePtrOutput) HttpIdleTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *int {
		if v == nil {
			return nil
		}
		return v.HttpIdleTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// A unique ID that can be used to identify and reference a load balancer.
func (o LoadBalancerTypePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// An attribute containing the public-facing IP address of the load balancer.
func (o LoadBalancerTypePtrOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(pulumi.StringPtrOutput)
}

// A human-readable name for a load balancer instance.
func (o LoadBalancerTypePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project. If an invalid project ID is provided, the load balancer will not be created.
func (o LoadBalancerTypePtrOutput) ProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.ProjectId
	}).(pulumi.StringPtrOutput)
}

// A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.
func (o LoadBalancerTypePtrOutput) RedirectHttpToHttps() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *bool {
		if v == nil {
			return nil
		}
		return v.RedirectHttpToHttps
	}).(pulumi.BoolPtrOutput)
}

// This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes.
// * `lb-small` = 1 node
// * `lb-medium` = 3 nodes
// * `lb-large` = 6 nodes
//
// You can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.
func (o LoadBalancerTypePtrOutput) Size() LoadBalancerBaseSizePtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *LoadBalancerBaseSize {
		if v == nil {
			return nil
		}
		return v.Size
	}).(LoadBalancerBaseSizePtrOutput)
}

// How many nodes the load balancer contains. Each additional node increases the load balancer's ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.
func (o LoadBalancerTypePtrOutput) SizeUnit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *int {
		if v == nil {
			return nil
		}
		return v.SizeUnit
	}).(pulumi.IntPtrOutput)
}

// A status string indicating the current state of the load balancer. This can be `new`, `active`, or `errored`.
func (o LoadBalancerTypePtrOutput) Status() LoadBalancerBaseStatusPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *LoadBalancerBaseStatus {
		if v == nil {
			return nil
		}
		return v.Status
	}).(LoadBalancerBaseStatusPtrOutput)
}

// An object specifying sticky sessions settings for the load balancer.
func (o LoadBalancerTypePtrOutput) StickySessions() StickySessionsPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *StickySessions {
		if v == nil {
			return nil
		}
		return v.StickySessions
	}).(StickySessionsPtrOutput)
}

// The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
func (o LoadBalancerTypePtrOutput) Tag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.Tag
	}).(pulumi.StringPtrOutput)
}

// A string specifying the UUID of the VPC to which the load balancer is assigned.
func (o LoadBalancerTypePtrOutput) VpcUuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerType) *string {
		if v == nil {
			return nil
		}
		return v.VpcUuid
	}).(pulumi.StringPtrOutput)
}

type LoadBalancerTypeArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancerTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancerType)(nil)).Elem()
}

func (o LoadBalancerTypeArrayOutput) ToLoadBalancerTypeArrayOutput() LoadBalancerTypeArrayOutput {
	return o
}

func (o LoadBalancerTypeArrayOutput) ToLoadBalancerTypeArrayOutputWithContext(ctx context.Context) LoadBalancerTypeArrayOutput {
	return o
}

func (o LoadBalancerTypeArrayOutput) Index(i pulumi.IntInput) LoadBalancerTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancerType {
		return vs[0].([]LoadBalancerType)[vs[1].(int)]
	}).(LoadBalancerTypeOutput)
}

type LoadBalancerPropertiesRegion struct {
	// This is a boolean value that represents whether new Droplets can be created in this region.
	Available bool `pulumi:"available"`
	// This attribute is set to an array which contains features available in this region
	Features []string `pulumi:"features"`
	// The display name of the region.  This will be a full name that is used in the control panel and other interfaces.
	Name string `pulumi:"name"`
	// This attribute is set to an array which contains the identifying slugs for the sizes available in this region.
	Sizes []string `pulumi:"sizes"`
	// A human-readable string that is used as a unique identifier for each region.
	Slug string `pulumi:"slug"`
}

type MetaMeta struct {
	// Number of objects returned by the request.
	Total *int `pulumi:"total"`
}

type MetaMetaOutput struct{ *pulumi.OutputState }

func (MetaMetaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetaMeta)(nil)).Elem()
}

func (o MetaMetaOutput) ToMetaMetaOutput() MetaMetaOutput {
	return o
}

func (o MetaMetaOutput) ToMetaMetaOutputWithContext(ctx context.Context) MetaMetaOutput {
	return o
}

// Number of objects returned by the request.
func (o MetaMetaOutput) Total() pulumi.IntPtrOutput {
	return o.ApplyT(func(v MetaMeta) *int { return v.Total }).(pulumi.IntPtrOutput)
}

type PageLinks struct {
	Pages *PageLinksPagesProperties `pulumi:"pages"`
}

type PageLinksOutput struct{ *pulumi.OutputState }

func (PageLinksOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PageLinks)(nil)).Elem()
}

func (o PageLinksOutput) ToPageLinksOutput() PageLinksOutput {
	return o
}

func (o PageLinksOutput) ToPageLinksOutputWithContext(ctx context.Context) PageLinksOutput {
	return o
}

func (o PageLinksOutput) Pages() PageLinksPagesPropertiesPtrOutput {
	return o.ApplyT(func(v PageLinks) *PageLinksPagesProperties { return v.Pages }).(PageLinksPagesPropertiesPtrOutput)
}

type PageLinksPtrOutput struct{ *pulumi.OutputState }

func (PageLinksPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PageLinks)(nil)).Elem()
}

func (o PageLinksPtrOutput) ToPageLinksPtrOutput() PageLinksPtrOutput {
	return o
}

func (o PageLinksPtrOutput) ToPageLinksPtrOutputWithContext(ctx context.Context) PageLinksPtrOutput {
	return o
}

func (o PageLinksPtrOutput) Elem() PageLinksOutput {
	return o.ApplyT(func(v *PageLinks) PageLinks {
		if v != nil {
			return *v
		}
		var ret PageLinks
		return ret
	}).(PageLinksOutput)
}

func (o PageLinksPtrOutput) Pages() PageLinksPagesPropertiesPtrOutput {
	return o.ApplyT(func(v *PageLinks) *PageLinksPagesProperties {
		if v == nil {
			return nil
		}
		return v.Pages
	}).(PageLinksPagesPropertiesPtrOutput)
}

type PageLinksPagesProperties struct {
	First *string `pulumi:"first"`
	Last  *string `pulumi:"last"`
	Next  *string `pulumi:"next"`
	Prev  *string `pulumi:"prev"`
}

type PageLinksPagesPropertiesOutput struct{ *pulumi.OutputState }

func (PageLinksPagesPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PageLinksPagesProperties)(nil)).Elem()
}

func (o PageLinksPagesPropertiesOutput) ToPageLinksPagesPropertiesOutput() PageLinksPagesPropertiesOutput {
	return o
}

func (o PageLinksPagesPropertiesOutput) ToPageLinksPagesPropertiesOutputWithContext(ctx context.Context) PageLinksPagesPropertiesOutput {
	return o
}

func (o PageLinksPagesPropertiesOutput) First() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PageLinksPagesProperties) *string { return v.First }).(pulumi.StringPtrOutput)
}

func (o PageLinksPagesPropertiesOutput) Last() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PageLinksPagesProperties) *string { return v.Last }).(pulumi.StringPtrOutput)
}

func (o PageLinksPagesPropertiesOutput) Next() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PageLinksPagesProperties) *string { return v.Next }).(pulumi.StringPtrOutput)
}

func (o PageLinksPagesPropertiesOutput) Prev() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PageLinksPagesProperties) *string { return v.Prev }).(pulumi.StringPtrOutput)
}

type PageLinksPagesPropertiesPtrOutput struct{ *pulumi.OutputState }

func (PageLinksPagesPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PageLinksPagesProperties)(nil)).Elem()
}

func (o PageLinksPagesPropertiesPtrOutput) ToPageLinksPagesPropertiesPtrOutput() PageLinksPagesPropertiesPtrOutput {
	return o
}

func (o PageLinksPagesPropertiesPtrOutput) ToPageLinksPagesPropertiesPtrOutputWithContext(ctx context.Context) PageLinksPagesPropertiesPtrOutput {
	return o
}

func (o PageLinksPagesPropertiesPtrOutput) Elem() PageLinksPagesPropertiesOutput {
	return o.ApplyT(func(v *PageLinksPagesProperties) PageLinksPagesProperties {
		if v != nil {
			return *v
		}
		var ret PageLinksPagesProperties
		return ret
	}).(PageLinksPagesPropertiesOutput)
}

func (o PageLinksPagesPropertiesPtrOutput) First() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PageLinksPagesProperties) *string {
		if v == nil {
			return nil
		}
		return v.First
	}).(pulumi.StringPtrOutput)
}

func (o PageLinksPagesPropertiesPtrOutput) Last() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PageLinksPagesProperties) *string {
		if v == nil {
			return nil
		}
		return v.Last
	}).(pulumi.StringPtrOutput)
}

func (o PageLinksPagesPropertiesPtrOutput) Next() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PageLinksPagesProperties) *string {
		if v == nil {
			return nil
		}
		return v.Next
	}).(pulumi.StringPtrOutput)
}

func (o PageLinksPagesPropertiesPtrOutput) Prev() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PageLinksPagesProperties) *string {
		if v == nil {
			return nil
		}
		return v.Prev
	}).(pulumi.StringPtrOutput)
}

// An object specifying sticky sessions settings for the load balancer.
type StickySessions struct {
	// The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.
	CookieName *string `pulumi:"cookieName"`
	// The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.
	CookieTtlSeconds *int `pulumi:"cookieTtlSeconds"`
	// An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.
	Type *StickySessionsType `pulumi:"type"`
}

// Defaults sets the appropriate defaults for StickySessions
func (val *StickySessions) Defaults() *StickySessions {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := StickySessionsType("none")
		tmp.Type = &type_
	}
	return &tmp
}

// StickySessionsInput is an input type that accepts StickySessionsArgs and StickySessionsOutput values.
// You can construct a concrete instance of `StickySessionsInput` via:
//
//	StickySessionsArgs{...}
type StickySessionsInput interface {
	pulumi.Input

	ToStickySessionsOutput() StickySessionsOutput
	ToStickySessionsOutputWithContext(context.Context) StickySessionsOutput
}

// An object specifying sticky sessions settings for the load balancer.
type StickySessionsArgs struct {
	// The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.
	CookieName pulumi.StringPtrInput `pulumi:"cookieName"`
	// The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.
	CookieTtlSeconds pulumi.IntPtrInput `pulumi:"cookieTtlSeconds"`
	// An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.
	Type StickySessionsTypePtrInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for StickySessionsArgs
func (val *StickySessionsArgs) Defaults() *StickySessionsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = StickySessionsType("none")
	}
	return &tmp
}
func (StickySessionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StickySessions)(nil)).Elem()
}

func (i StickySessionsArgs) ToStickySessionsOutput() StickySessionsOutput {
	return i.ToStickySessionsOutputWithContext(context.Background())
}

func (i StickySessionsArgs) ToStickySessionsOutputWithContext(ctx context.Context) StickySessionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StickySessionsOutput)
}

func (i StickySessionsArgs) ToStickySessionsPtrOutput() StickySessionsPtrOutput {
	return i.ToStickySessionsPtrOutputWithContext(context.Background())
}

func (i StickySessionsArgs) ToStickySessionsPtrOutputWithContext(ctx context.Context) StickySessionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StickySessionsOutput).ToStickySessionsPtrOutputWithContext(ctx)
}

// StickySessionsPtrInput is an input type that accepts StickySessionsArgs, StickySessionsPtr and StickySessionsPtrOutput values.
// You can construct a concrete instance of `StickySessionsPtrInput` via:
//
//	        StickySessionsArgs{...}
//
//	or:
//
//	        nil
type StickySessionsPtrInput interface {
	pulumi.Input

	ToStickySessionsPtrOutput() StickySessionsPtrOutput
	ToStickySessionsPtrOutputWithContext(context.Context) StickySessionsPtrOutput
}

type stickySessionsPtrType StickySessionsArgs

func StickySessionsPtr(v *StickySessionsArgs) StickySessionsPtrInput {
	return (*stickySessionsPtrType)(v)
}

func (*stickySessionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StickySessions)(nil)).Elem()
}

func (i *stickySessionsPtrType) ToStickySessionsPtrOutput() StickySessionsPtrOutput {
	return i.ToStickySessionsPtrOutputWithContext(context.Background())
}

func (i *stickySessionsPtrType) ToStickySessionsPtrOutputWithContext(ctx context.Context) StickySessionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StickySessionsPtrOutput)
}

// An object specifying sticky sessions settings for the load balancer.
type StickySessionsOutput struct{ *pulumi.OutputState }

func (StickySessionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StickySessions)(nil)).Elem()
}

func (o StickySessionsOutput) ToStickySessionsOutput() StickySessionsOutput {
	return o
}

func (o StickySessionsOutput) ToStickySessionsOutputWithContext(ctx context.Context) StickySessionsOutput {
	return o
}

func (o StickySessionsOutput) ToStickySessionsPtrOutput() StickySessionsPtrOutput {
	return o.ToStickySessionsPtrOutputWithContext(context.Background())
}

func (o StickySessionsOutput) ToStickySessionsPtrOutputWithContext(ctx context.Context) StickySessionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StickySessions) *StickySessions {
		return &v
	}).(StickySessionsPtrOutput)
}

// The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.
func (o StickySessionsOutput) CookieName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StickySessions) *string { return v.CookieName }).(pulumi.StringPtrOutput)
}

// The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.
func (o StickySessionsOutput) CookieTtlSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StickySessions) *int { return v.CookieTtlSeconds }).(pulumi.IntPtrOutput)
}

// An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.
func (o StickySessionsOutput) Type() StickySessionsTypePtrOutput {
	return o.ApplyT(func(v StickySessions) *StickySessionsType { return v.Type }).(StickySessionsTypePtrOutput)
}

type StickySessionsPtrOutput struct{ *pulumi.OutputState }

func (StickySessionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StickySessions)(nil)).Elem()
}

func (o StickySessionsPtrOutput) ToStickySessionsPtrOutput() StickySessionsPtrOutput {
	return o
}

func (o StickySessionsPtrOutput) ToStickySessionsPtrOutputWithContext(ctx context.Context) StickySessionsPtrOutput {
	return o
}

func (o StickySessionsPtrOutput) Elem() StickySessionsOutput {
	return o.ApplyT(func(v *StickySessions) StickySessions {
		if v != nil {
			return *v
		}
		var ret StickySessions
		return ret
	}).(StickySessionsOutput)
}

// The name of the cookie sent to the client. This attribute is only returned when using `cookies` for the sticky sessions type.
func (o StickySessionsPtrOutput) CookieName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StickySessions) *string {
		if v == nil {
			return nil
		}
		return v.CookieName
	}).(pulumi.StringPtrOutput)
}

// The number of seconds until the cookie set by the load balancer expires. This attribute is only returned when using `cookies` for the sticky sessions type.
func (o StickySessionsPtrOutput) CookieTtlSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StickySessions) *int {
		if v == nil {
			return nil
		}
		return v.CookieTtlSeconds
	}).(pulumi.IntPtrOutput)
}

// An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`.
func (o StickySessionsPtrOutput) Type() StickySessionsTypePtrOutput {
	return o.ApplyT(func(v *StickySessions) *StickySessionsType {
		if v == nil {
			return nil
		}
		return v.Type
	}).(StickySessionsTypePtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ForwardingRuleInput)(nil)).Elem(), ForwardingRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ForwardingRuleArrayInput)(nil)).Elem(), ForwardingRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HealthCheckInput)(nil)).Elem(), HealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HealthCheckPtrInput)(nil)).Elem(), HealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LbFirewallInput)(nil)).Elem(), LbFirewallArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LbFirewallPtrInput)(nil)).Elem(), LbFirewallArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StickySessionsInput)(nil)).Elem(), StickySessionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StickySessionsPtrInput)(nil)).Elem(), StickySessionsArgs{})
	pulumi.RegisterOutputType(ForwardingRuleOutput{})
	pulumi.RegisterOutputType(ForwardingRuleArrayOutput{})
	pulumi.RegisterOutputType(GetLoadBalancerPropertiesOutput{})
	pulumi.RegisterOutputType(HealthCheckOutput{})
	pulumi.RegisterOutputType(HealthCheckPtrOutput{})
	pulumi.RegisterOutputType(LbFirewallOutput{})
	pulumi.RegisterOutputType(LbFirewallPtrOutput{})
	pulumi.RegisterOutputType(ListLoadBalancersItemsOutput{})
	pulumi.RegisterOutputType(LoadBalancerTypeOutput{})
	pulumi.RegisterOutputType(LoadBalancerTypePtrOutput{})
	pulumi.RegisterOutputType(LoadBalancerTypeArrayOutput{})
	pulumi.RegisterOutputType(MetaMetaOutput{})
	pulumi.RegisterOutputType(PageLinksOutput{})
	pulumi.RegisterOutputType(PageLinksPtrOutput{})
	pulumi.RegisterOutputType(PageLinksPagesPropertiesOutput{})
	pulumi.RegisterOutputType(PageLinksPagesPropertiesPtrOutput{})
	pulumi.RegisterOutputType(StickySessionsOutput{})
	pulumi.RegisterOutputType(StickySessionsPtrOutput{})
}
